---
layout: post
title: 260115 BFS ë„ˆë¹„ìš°ì„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì™„ë²½ ê°€ì´ë“œ
comments: true
tags:
- BFS
- ì•Œê³ ë¦¬ì¦˜
- ê·¸ë˜í”„íƒìƒ‰
- í
- ë„ˆë¹„ìš°ì„ íƒìƒ‰
- ì½”ë”©í…ŒìŠ¤íŠ¸
- Unity
- DFS
- ìµœë‹¨ê²½ë¡œ
- ìë£Œêµ¬ì¡°
---

> ê·¸ë˜í”„ì™€ íŠ¸ë¦¬ë¥¼ íƒìƒ‰í•˜ëŠ” ê°€ì¥ ê¸°ë³¸ì ì´ê³  ê°•ë ¥í•œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ì¸ BFSë¥¼ ë§ˆìŠ¤í„°í•´ë³´ì„¸ìš”!

---

# ğŸ“š ëª©ì°¨

1. [BFSë€ ë¬´ì—‡ì¸ê°€?]()
2. [BFS ë™ì‘ ì›ë¦¬]()
3. [í(Queue)ì˜ ì—­í• ]()
4. [ì˜ì‚¬ì½”ë“œ(Pseudocode)]()
5. [ë‹¤ì–‘í•œ ì–¸ì–´ êµ¬í˜„]()
6. [ì‹œê°„/ê³µê°„ ë³µì¡ë„ ë¶„ì„]()
7. [BFS vs DFS ë¹„êµ]()
8. [ì‘ìš© ë¶„ì•¼]()
9. [Unity ê²Œì„ ê°œë°œ í™œìš©]()
10. [ìµœì í™” ê¸°ë²•]()
11. [ì‹¤ì „ ì½”ë”© í…ŒìŠ¤íŠ¸ ë¬¸ì œ]()
12. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…]()
13. [ì°¸ê³  ìë£Œ]()

---


# ğŸ” BFSë€ ë¬´ì—‡ì¸ê°€?

## ğŸ“– ì •ì˜

**BFS (Breadth-First Search, ë„ˆë¹„ ìš°ì„  íƒìƒ‰)** ëŠ” ê·¸ë˜í”„ë‚˜ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¥¼ íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì‹œì‘ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ íƒìƒ‰í•˜ë©°, **ë ˆë²¨ë³„ë¡œ íƒìƒ‰**ì„ ì§„í–‰í•©ë‹ˆë‹¤.

## ğŸ¨ í•µì‹¬ ê°œë…

- ğŸŒŠ **ë¬¼ê²°ì´ í¼ì§€ë“¯ì´** íƒìƒ‰ì´ ì§„í–‰ë©ë‹ˆë‹¤
- ğŸ“ **ìµœë‹¨ ê±°ë¦¬**ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤ (ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” ê·¸ë˜í”„)
- ğŸ¯ **ë ˆë²¨ ìˆœì„œ**ëŒ€ë¡œ ë°©ë¬¸í•©ë‹ˆë‹¤
- ğŸ“¦ **í(Queue)** ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤

## ğŸ›ï¸ ì—­ì‚¬

BFSëŠ” **1959ë…„ Edward F. Moore**ì— ì˜í•´ ì²˜ìŒ ë°œí‘œë˜ì—ˆìœ¼ë©°, ë¯¸ë¡œ íƒìƒ‰ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ê¸° ìœ„í•´ ê°œë°œë˜ì—ˆìŠµë‹ˆë‹¤. ì´í›„ ì»´í“¨í„° ê³¼í•™ì˜ ê¸°ì´ˆ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìë¦¬ì¡ì•˜ìŠµë‹ˆë‹¤.
---

# âš™ï¸ BFS ë™ì‘ ì›ë¦¬

## ğŸ¬ ë‹¨ê³„ë³„ ë™ì‘ ê³¼ì •

```
1ï¸âƒ£ ì‹œì‘ ë…¸ë“œë¥¼ íì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬
2ï¸âƒ£ íì—ì„œ ë…¸ë“œë¥¼ í•˜ë‚˜ êº¼ëƒ„
3ï¸âƒ£ êº¼ë‚¸ ë…¸ë“œì˜ ì¸ì ‘ ë…¸ë“œ ì¤‘ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë¥¼ ëª¨ë‘ íì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬
4ï¸âƒ£ íê°€ ë¹Œ ë•Œê¹Œì§€ 2~3ë²ˆ ë°˜ë³µ
```

## ğŸ¨ ì‹œê°ì  í‘œí˜„ (ASCII ë‹¤ì´ì–´ê·¸ë¨)

```
ê·¸ë˜í”„ ì˜ˆì‹œ:
     1
    / \
   2   3
  / \   \
 4   5   6

íƒìƒ‰ ìˆœì„œ:
Level 0: [1]
Level 1: [2, 3]
Level 2: [4, 5, 6]

í ìƒíƒœ ë³€í™”:
Step 1: Queue = [1]          Visited = {1}
Step 2: Queue = [2, 3]       Visited = {1, 2, 3}
Step 3: Queue = [3, 4, 5]    Visited = {1, 2, 3, 4, 5}
Step 4: Queue = [4, 5, 6]    Visited = {1, 2, 3, 4, 5, 6}
Step 5: Queue = [5, 6]       Visited = {1, 2, 3, 4, 5, 6}
Step 6: Queue = [6]          Visited = {1, 2, 3, 4, 5, 6}
Step 7: Queue = []           Visited = {1, 2, 3, 4, 5, 6}
```

## ğŸ“Š Mermaid ë‹¤ì´ì–´ê·¸ë¨

```
graph TD
    A[ì‹œì‘: íì— ì‹œì‘ ë…¸ë“œ ì‚½ì…] --> B[íê°€ ë¹„ì–´ìˆëŠ”ê°€?]
    B -->|ì˜ˆ| C[ì¢…ë£Œ]
    B -->|ì•„ë‹ˆì˜¤| D[íì—ì„œ ë…¸ë“œ êº¼ë‚´ê¸°]
    D --> E[í˜„ì¬ ë…¸ë“œ ì²˜ë¦¬]
    E --> F[ì¸ì ‘ ë…¸ë“œ í™•ì¸]
    F --> G[ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ ë…¸ë“œë¥¼<br/>íì— ì¶”ê°€]
    G --> H[ë°©ë¬¸ ì²˜ë¦¬]
    H --> B
    
    style A fill:#e1f5ff
    style C fill:#ffe1e1
    style D fill:#fff4e1
    style E fill:#e1ffe1
```

## ğŸ”„ íƒìƒ‰ ê³¼ì • ì• ë‹ˆë©”ì´ì…˜ (ë‹¨ê³„ë³„)

### Step 1: ì´ˆê¸° ìƒíƒœ

```
Queue: [1]
Visited: {1}
Current: -

     (1)
    /   \
   2     3
  / \     \
 4   5     6
```

### Step 2: ë…¸ë“œ 1 ë°©ë¬¸

```
Queue: [2, 3]
Visited: {1, 2, 3}
Current: 1

     [1]
    /   \
  (2)   (3)
  / \     \
 4   5     6
```

### Step 3: ë…¸ë“œ 2 ë°©ë¬¸

```
Queue: [3, 4, 5]
Visited: {1, 2, 3, 4, 5}
Current: 2

     [1]
    /   \
  [2]   (3)
  / \     \
(4) (5)    6
```

### Step 4: ë…¸ë“œ 3 ë°©ë¬¸

```
Queue: [4, 5, 6]
Visited: {1, 2, 3, 4, 5, 6}
Current: 3

     [1]
    /   \
  [2]   [3]
  / \     \
(4) (5)   (6)
```

**ë²”ë¡€:**
- `( )` : íì— ëŒ€ê¸° ì¤‘
- `\[ \]` : ë°©ë¬¸ ì™„ë£Œ
- ìˆ«ì : ë¯¸ë°©ë¬¸
---

# ğŸ“¦ í(Queue)ì˜ ì—­í• 

## ğŸ¯ ì™œ íë¥¼ ì‚¬ìš©í• ê¹Œ?

BFSëŠ” **FIFO (First In First Out)** ì›ì¹™ì„ ë”°ë¦…ë‹ˆë‹¤. ë¨¼ì € ë°œê²¬í•œ ë…¸ë“œë¥¼ ë¨¼ì € íƒìƒ‰í•´ì•¼ ë ˆë²¨ ìˆœì„œë¥¼ ë³´ì¥í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

## ğŸ“Š í vs ìŠ¤íƒ ë¹„êµ

```
graph LR
    subgraph "Queue (BFS)"
        Q1[ì•] --> Q2[2] --> Q3[3] --> Q4[4] --> Q5[ë’¤]
        Q5 -.ì…ë ¥.-> Q5
        Q1 -.ì¶œë ¥.-> Q1
    end
    
    subgraph "Stack (DFS)"
        S1[ë°‘] --> S2[2] --> S3[3] --> S4[4] --> S5[ìœ„]
        S5 -.ì…ë ¥/ì¶œë ¥.-> S5
    end
```

## ğŸ”§ í êµ¬í˜„ ë°©ë²•

### Python - `collections.deque`

```
from collections import deque

queue = deque()
queue.append(1)      # ë’¤ì— ì¶”ê°€
node = queue.popleft()  # ì•ì—ì„œ ì œê±°
```

### C# - `Queue\<T\>`

```
using System.Collections.Generic;

Queue<int> queue = new Queue<int>();
queue.Enqueue(1);    // ë’¤ì— ì¶”ê°€
int node = queue.Dequeue();  // ì•ì—ì„œ ì œê±°
```

### C++ - `std::queue`

```
#include <queue>

std::queue<int> queue;
queue.push(1);       // ë’¤ì— ì¶”ê°€
int node = queue.front();  // ì• í™•ì¸
queue.pop();         // ì•ì—ì„œ ì œê±°
```

### Java - `LinkedList` (Queue ì¸í„°í˜ì´ìŠ¤)

```
import java.util.Queue;
import java.util.LinkedList;

Queue<Integer> queue = new LinkedList<>();
queue.offer(1);      // ë’¤ì— ì¶”ê°€
int node = queue.poll();  // ì•ì—ì„œ ì œê±°
```

---

# ğŸ“ ì˜ì‚¬ì½”ë“œ(Pseudocode)

## ê¸°ë³¸ BFS ì˜ì‚¬ì½”ë“œ

```
BFS(graph, start_node):
    create empty queue Q
    create empty set visited
    
    Q.enqueue(start_node)
    visited.add(start_node)
    
    while Q is not empty:
        current = Q.dequeue()
        
        // í˜„ì¬ ë…¸ë“œ ì²˜ë¦¬
        process(current)
        
        // ì¸ì ‘ ë…¸ë“œ íƒìƒ‰
        for each neighbor of current in graph:
            if neighbor not in visited:
                visited.add(neighbor)
                Q.enqueue(neighbor)
```

## ìµœë‹¨ ê±°ë¦¬ ì¶”ì  BFS

```
BFS_with_distance(graph, start_node):
    create empty queue Q
    create distance map (node -> distance)
    
    Q.enqueue(start_node)
    distance[start_node] = 0
    
    while Q is not empty:
        current = Q.dequeue()
        current_dist = distance[current]
        
        for each neighbor of current in graph:
            if neighbor not in distance:
                distance[neighbor] = current_dist + 1
                Q.enqueue(neighbor)
    
    return distance
```

## ê²½ë¡œ ì¶”ì  BFS

```
BFS_with_path(graph, start, goal):
    create empty queue Q
    create parent map (node -> parent_node)
    
    Q.enqueue(start)
    parent[start] = null
    
    while Q is not empty:
        current = Q.dequeue()
        
        if current == goal:
            return reconstruct_path(parent, start, goal)
        
        for each neighbor of current in graph:
            if neighbor not in parent:
                parent[neighbor] = current
                Q.enqueue(neighbor)
    
    return null  // ê²½ë¡œ ì—†ìŒ

reconstruct_path(parent, start, goal):
    path = []
    current = goal
    
    while current != null:
        path.prepend(current)
        current = parent[current]
    
    return path
```

---

# ğŸ’» ë‹¤ì–‘í•œ ì–¸ì–´ êµ¬í˜„

## ğŸ Python êµ¬í˜„

### ê¸°ë³¸ BFS (ì¸ì ‘ ë¦¬ìŠ¤íŠ¸)

```
from collections import deque
from typing import List, Dict, Set

def bfs(graph: Dict[int, List[int]], start: int) -> List[int]:
    """
    BFS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
    
    Args:
        graph: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
        start: ì‹œì‘ ë…¸ë“œ
    
    Returns:
        ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸
    """
    visited: Set[int] = set()
    queue: deque = deque([start])
    result: List[int] = []
    
    visited.add(start)
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        # ì¸ì ‘ ë…¸ë“œ íƒìƒ‰
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result

# ì‚¬ìš© ì˜ˆì œ
if __name__ == "__main__":
    # ê·¸ë˜í”„ ì •ì˜
    graph = {
        1: [2, 3],
        2: [1, 4, 5],
        3: [1, 6],
        4: [2],
        5: [2],
        6: [3]
    }
    
    result = bfs(graph, 1)
    print(f"BFS íƒìƒ‰ ê²°ê³¼: {result}")
    # ì¶œë ¥: BFS íƒìƒ‰ ê²°ê³¼: [1, 2, 3, 4, 5, 6]
```

### ìµœë‹¨ ê±°ë¦¬ ê³„ì‚° BFS

```
from collections import deque
from typing import Dict, List, Optional

def bfs_shortest_path(graph: Dict[int, List[int]], 
                       start: int, 
                       goal: int) -> Optional[List[int]]:
    """
    BFSë¥¼ ì‚¬ìš©í•˜ì—¬ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°
    
    Args:
        graph: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
        start: ì‹œì‘ ë…¸ë“œ
        goal: ëª©í‘œ ë…¸ë“œ
    
    Returns:
        ìµœë‹¨ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸ (ê²½ë¡œê°€ ì—†ìœ¼ë©´ None)
    """
    if start == goal:
        return [start]
    
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        node, path = queue.popleft()
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                new_path = path + [neighbor]
                
                if neighbor == goal:
                    return new_path
                
                visited.add(neighbor)
                queue.append((neighbor, new_path))
    
    return None

# ì‚¬ìš© ì˜ˆì œ
graph = {
    1: [2, 3],
    2: [1, 4, 5],
    3: [1, 6],
    4: [2, 7],
    5: [2],
    6: [3, 7],
    7: [4, 6]
}

path = bfs_shortest_path(graph, 1, 7)
if path:
    print(f"ìµœë‹¨ ê²½ë¡œ: {' -> '.join(map(str, path))}")
    print(f"ê±°ë¦¬: {len(path) - 1}")
# ì¶œë ¥:
# ìµœë‹¨ ê²½ë¡œ: 1 -> 2 -> 4 -> 7
# ê±°ë¦¬: 3
```

### ê·¸ë¦¬ë“œ(2D ë°°ì—´) BFS

```
from collections import deque
from typing import List, Tuple, Set

def bfs_grid(grid: List[List[int]], 
             start: Tuple[int, int], 
             goal: Tuple[int, int]) -> int:
    """
    2D ê·¸ë¦¬ë“œì—ì„œ BFSë¡œ ìµœë‹¨ ê±°ë¦¬ ì°¾ê¸°
    0: ì´ë™ ê°€ëŠ¥, 1: ë²½
    
    Args:
        grid: 2D ê·¸ë¦¬ë“œ
        start: ì‹œì‘ ì¢Œí‘œ (row, col)
        goal: ëª©í‘œ ì¢Œí‘œ (row, col)
    
    Returns:
        ìµœë‹¨ ê±°ë¦¬ (ê²½ë¡œê°€ ì—†ìœ¼ë©´ -1)
    """
    rows, cols = len(grid), len(grid[0])
    
    # ìƒí•˜ì¢Œìš° ì´ë™
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)
    visited: Set[Tuple[int, int]] = {start}
    
    while queue:
        row, col, dist = queue.popleft()
        
        # ëª©í‘œ ë„ë‹¬
        if (row, col) == goal:
            return dist
        
        # 4ë°©í–¥ íƒìƒ‰
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            # ë²”ìœ„ ì²´í¬
            if 0 <= new_row < rows and 0 <= new_col < cols:
                # ë²½ì´ ì•„ë‹ˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ìš°
                if grid[new_row][new_col] == 0 and (new_row, new_col) not in visited:
                    visited.add((new_row, new_col))
                    queue.append((new_row, new_col, dist + 1))
    
    return -1  # ê²½ë¡œ ì—†ìŒ

# ì‚¬ìš© ì˜ˆì œ
if __name__ == "__main__":
    maze = [
        [0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 1, 1, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 0, 1, 0]
    ]
    
    distance = bfs_grid(maze, (0, 0), (4, 4))
    print(f"ìµœë‹¨ ê±°ë¦¬: {distance}")
    # ì¶œë ¥: ìµœë‹¨ ê±°ë¦¬: 8
```

## ğŸ”· C# êµ¬í˜„

### ê¸°ë³¸ BFS

```
using System;
using System.Collections.Generic;
using System.Linq;

public class BFSAlgorithm
{
    /// <summary>
    /// BFS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
    /// </summary>
    /// <param name="graph">ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„</param>
    /// <param name="start">ì‹œì‘ ë…¸ë“œ</param>
    /// <returns>ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸</returns>
    public static List<int> BFS(Dictionary<int, List<int>> graph, int start)
    {
        var visited = new HashSet<int>();
        var queue = new Queue<int>();
        var result = new List<int>();
        
        queue.Enqueue(start);
        visited.Add(start);
        
        while (queue.Count > 0)
        {
            var node = queue.Dequeue();
            result.Add(node);
            
            // ì¸ì ‘ ë…¸ë“œê°€ ìˆëŠ”ì§€ í™•ì¸
            if (graph.ContainsKey(node))
            {
                foreach (var neighbor in graph[node])
                {
                    if (!visited.Contains(neighbor))
                    {
                        visited.Add(neighbor);
                        queue.Enqueue(neighbor);
                    }
                }
            }
        }
        
        return result;
    }
    
    // ì‚¬ìš© ì˜ˆì œ
    public static void Main()
    {
        var graph = new Dictionary<int, List<int>>
        {
            { 1, new List<int> { 2, 3 } },
            { 2, new List<int> { 1, 4, 5 } },
            { 3, new List<int> { 1, 6 } },
            { 4, new List<int> { 2 } },
            { 5, new List<int> { 2 } },
            { 6, new List<int> { 3 } }
        };
        
        var result = BFS(graph, 1);
        Console.WriteLine($"BFS íƒìƒ‰ ê²°ê³¼: {string.Join(", ", result)}");
        // ì¶œë ¥: BFS íƒìƒ‰ ê²°ê³¼: 1, 2, 3, 4, 5, 6
    }
}
```

### Unityìš© BFS (Grid Pathfinding)

```
using UnityEngine;
using System.Collections.Generic;

public class UnityBFSPathfinding : MonoBehaviour
{
    private struct Cell
    {
        public int Row;
        public int Col;
        public int Distance;
        
        public Cell(int row, int col, int distance)
        {
            Row = row;
            Col = col;
            Distance = distance;
        }
    }
    
    /// <summary>
    /// Unity ê·¸ë¦¬ë“œì—ì„œ BFS ê²½ë¡œ ì°¾ê¸°
    /// </summary>
    /// <param name="grid">2D ê·¸ë¦¬ë“œ (true: ì´ë™ ê°€ëŠ¥, false: ë²½)</param>
    /// <param name="start">ì‹œì‘ ìœ„ì¹˜</param>
    /// <param name="goal">ëª©í‘œ ìœ„ì¹˜</param>
    /// <returns>ìµœë‹¨ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸</returns>
    public List<Vector2Int> FindPath(bool[,] grid, Vector2Int start, Vector2Int goal)
    {
        var rows = grid.GetLength(0);
        var cols = grid.GetLength(1);
        
        // 4ë°©í–¥ ì´ë™ (ìƒí•˜ì¢Œìš°)
        var directions = new Vector2Int[]
        {
            new Vector2Int(0, 1),   // ì˜¤ë¥¸ìª½
            new Vector2Int(1, 0),   // ì•„ë˜
            new Vector2Int(0, -1),  // ì™¼ìª½
            new Vector2Int(-1, 0)   // ìœ„
        };
        
        var queue = new Queue<Cell>();
        var visited = new HashSet<Vector2Int>();
        var parent = new Dictionary<Vector2Int, Vector2Int>();
        
        queue.Enqueue(new Cell(start.x, start.y, 0));
        visited.Add(start);
        parent[start] = start;
        
        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            var currentPos = new Vector2Int(current.Row, current.Col);
            
            // ëª©í‘œ ë„ë‹¬
            if (currentPos == goal)
            {
                return ReconstructPath(parent, start, goal);
            }
            
            // 4ë°©í–¥ íƒìƒ‰
            foreach (var dir in directions)
            {
                var newRow = current.Row + dir.x;
                var newCol = current.Col + dir.y;
                var newPos = new Vector2Int(newRow, newCol);
                
                // ë²”ìœ„ ì²´í¬
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols)
                {
                    // ì´ë™ ê°€ëŠ¥í•˜ê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ìš°
                    if (grid[newRow, newCol] && !visited.Contains(newPos))
                    {
                        visited.Add(newPos);
                        parent[newPos] = currentPos;
                        queue.Enqueue(new Cell(newRow, newCol, current.Distance + 1));
                    }
                }
            }
        }
        
        return null; // ê²½ë¡œ ì—†ìŒ
    }
    
    /// <summary>
    /// ë¶€ëª¨ ë§µì„ ì‚¬ìš©í•˜ì—¬ ê²½ë¡œ ì¬êµ¬ì„±
    /// </summary>
    private List<Vector2Int> ReconstructPath(Dictionary<Vector2Int, Vector2Int> parent, 
                                              Vector2Int start, 
                                              Vector2Int goal)
    {
        var path = new List<Vector2Int>();
        var current = goal;
        
        while (current != start)
        {
            path.Add(current);
            current = parent[current];
        }
        
        path.Add(start);
        path.Reverse();
        
        return path;
    }
    
    // Unity ì—ë””í„°ì—ì„œ ê²½ë¡œ ì‹œê°í™”
    private void OnDrawGizmos()
    {
        // ê²½ë¡œê°€ ìˆë‹¤ë©´ ì„ ìœ¼ë¡œ ê·¸ë¦¬ê¸°
        // (ì‹¤ì œ ì‚¬ìš© ì‹œ êµ¬í˜„)
    }
}

```

## ğŸ”µ C++ êµ¬í˜„

### ê¸°ë³¸ BFS

```
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>
#include <unordered_map>

using namespace std;

/**
 * BFS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
 * @param graph ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
 * @param start ì‹œì‘ ë…¸ë“œ
 * @return ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë…¸ë“œ ë²¡í„°
 */
vector<int> bfs(unordered_map<int, vector<int>>& graph, int start) {
    unordered_set<int> visited;
    queue<int> q;
    vector<int> result;
    
    q.push(start);
    visited.insert(start);
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        
        // ì¸ì ‘ ë…¸ë“œ íƒìƒ‰
        if (graph.find(node) != graph.end()) {
            for (int neighbor : graph[node]) {
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
    }
    
    return result;
}

// ì‚¬ìš© ì˜ˆì œ
int main() {
    // ê·¸ë˜í”„ ì •ì˜
    unordered_map<int, vector<int>> graph;
    graph[1] = {2, 3};
    graph[2] = {1, 4, 5};
    graph[3] = {1, 6};
    graph[4] = {2};
    graph[5] = {2};
    graph[6] = {3};
    
    vector<int> result = bfs(graph, 1);
    
    cout << "BFS íƒìƒ‰ ê²°ê³¼: ";
    for (int node : result) {
        cout << node << " ";
    }
    cout << endl;
    // ì¶œë ¥: BFS íƒìƒ‰ ê²°ê³¼: 1 2 3 4 5 6
    
    return 0;
}
```

### ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°

```
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <climits>

using namespace std;

/**
 * BFSë¥¼ ì‚¬ìš©í•œ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
 * @param graph ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
 * @param start ì‹œì‘ ë…¸ë“œ
 * @return ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ë§µ
 */
unordered_map<int, int> bfs_shortest_distance(unordered_map<int, vector<int>>& graph, int start) {
    unordered_map<int, int> distance;
    queue<int> q;
    
    q.push(start);
    distance[start] = 0;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        int current_dist = distance[node];
        
        if (graph.find(node) != graph.end()) {
            for (int neighbor : graph[node]) {
                if (distance.find(neighbor) == distance.end()) {
                    distance[neighbor] = current_dist + 1;
                    q.push(neighbor);
                }
            }
        }
    }
    
    return distance;
}

int main() {
    unordered_map<int, vector<int>> graph;
    graph[1] = {2, 3};
    graph[2] = {1, 4, 5};
    graph[3] = {1, 6};
    graph[4] = {2, 7};
    graph[5] = {2};
    graph[6] = {3, 7};
    graph[7] = {4, 6};
    
    auto distances = bfs_shortest_distance(graph, 1);
    
    cout << "ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬:\n";
    for (auto& [node, dist] : distances) {
        cout << "ë…¸ë“œ " << node << ": " << dist << "\n";
    }
    
    return 0;
}
```

## â˜• Java êµ¬í˜„

### ê¸°ë³¸ BFS

```
import java.util.*;

public class BFSAlgorithm {
    
    /**
     * BFS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
     * @param graph ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
     * @param start ì‹œì‘ ë…¸ë“œ
     * @return ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸
     */
    public static List<Integer> bfs(Map<Integer, List<Integer>> graph, int start) {
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        
        queue.offer(start);
        visited.add(start);
        
        while (!queue.isEmpty()) {
            int node = queue.poll();
            result.add(node);
            
            // ì¸ì ‘ ë…¸ë“œ íƒìƒ‰
            if (graph.containsKey(node)) {
                for (int neighbor : graph.get(node)) {
                    if (!visited.contains(neighbor)) {
                        visited.add(neighbor);
                        queue.offer(neighbor);
                    }
                }
            }
        }
        
        return result;
    }
    
    // ì‚¬ìš© ì˜ˆì œ
    public static void main(String[] args) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(1, Arrays.asList(2, 3));
        graph.put(2, Arrays.asList(1, 4, 5));
        graph.put(3, Arrays.asList(1, 6));
        graph.put(4, Arrays.asList(2));
        graph.put(5, Arrays.asList(2));
        graph.put(6, Arrays.asList(3));
        
        List<Integer> result = bfs(graph, 1);
        System.out.println("BFS íƒìƒ‰ ê²°ê³¼: " + result);
        // ì¶œë ¥: BFS íƒìƒ‰ ê²°ê³¼: [1, 2, 3, 4, 5, 6]
    }
}
```

### ê·¸ë¦¬ë“œ BFS (ìµœë‹¨ ê²½ë¡œ)
