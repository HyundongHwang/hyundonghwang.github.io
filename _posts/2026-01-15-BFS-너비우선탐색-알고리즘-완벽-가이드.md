---
layout: post
title: 260115 BFS ë„ˆë¹„ìš°ì„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì™„ë²½ ê°€ì´ë“œ
comments: true
tags:
- BFS
- ì•Œê³ ë¦¬ì¦˜
- ê·¸ë˜í”„íƒìƒ‰
- í
- ë„ˆë¹„ìš°ì„ íƒìƒ‰
- ì½”ë”©í…ŒìŠ¤íŠ¸
- Unity
- DFS
- ìµœë‹¨ê²½ë¡œ
- ìë£Œêµ¬ì¡°
---

> ê·¸ë˜í”„ì™€ íŠ¸ë¦¬ë¥¼ íƒìƒ‰í•˜ëŠ” ê°€ì¥ ê¸°ë³¸ì ì´ê³  ê°•ë ¥í•œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ì¸ BFSë¥¼ ë§ˆìŠ¤í„°í•´ë³´ì„¸ìš”!

---

# ğŸ“š ëª©ì°¨

1. [BFSë€ ë¬´ì—‡ì¸ê°€?]()
2. [BFS ë™ì‘ ì›ë¦¬]()
3. [í(Queue)ì˜ ì—­í• ]()
4. [ì˜ì‚¬ì½”ë“œ(Pseudocode)]()
5. [ë‹¤ì–‘í•œ ì–¸ì–´ êµ¬í˜„]()
6. [ì‹œê°„/ê³µê°„ ë³µì¡ë„ ë¶„ì„]()
7. [BFS vs DFS ë¹„êµ]()
8. [ì‘ìš© ë¶„ì•¼]()
9. [Unity ê²Œì„ ê°œë°œ í™œìš©]()
10. [ìµœì í™” ê¸°ë²•]()
11. [ì‹¤ì „ ì½”ë”© í…ŒìŠ¤íŠ¸ ë¬¸ì œ]()
12. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…]()
13. [ì°¸ê³  ìë£Œ]()

---


# ğŸ” BFSë€ ë¬´ì—‡ì¸ê°€?

## ğŸ“– ì •ì˜

**BFS (Breadth-First Search, ë„ˆë¹„ ìš°ì„  íƒìƒ‰)** ëŠ” ê·¸ë˜í”„ë‚˜ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¥¼ íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì‹œì‘ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ íƒìƒ‰í•˜ë©°, **ë ˆë²¨ë³„ë¡œ íƒìƒ‰**ì„ ì§„í–‰í•©ë‹ˆë‹¤.

## ğŸ¨ í•µì‹¬ ê°œë…

- ğŸŒŠ **ë¬¼ê²°ì´ í¼ì§€ë“¯ì´** íƒìƒ‰ì´ ì§„í–‰ë©ë‹ˆë‹¤
- ğŸ“ **ìµœë‹¨ ê±°ë¦¬**ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤ (ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” ê·¸ë˜í”„)
- ğŸ¯ **ë ˆë²¨ ìˆœì„œ**ëŒ€ë¡œ ë°©ë¬¸í•©ë‹ˆë‹¤
- ğŸ“¦ **í(Queue)** ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤

## ğŸ›ï¸ ì—­ì‚¬

BFSëŠ” **1959ë…„ Edward F. Moore**ì— ì˜í•´ ì²˜ìŒ ë°œí‘œë˜ì—ˆìœ¼ë©°, ë¯¸ë¡œ íƒìƒ‰ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ê¸° ìœ„í•´ ê°œë°œë˜ì—ˆìŠµë‹ˆë‹¤. ì´í›„ ì»´í“¨í„° ê³¼í•™ì˜ ê¸°ì´ˆ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìë¦¬ì¡ì•˜ìŠµë‹ˆë‹¤.
---

# âš™ï¸ BFS ë™ì‘ ì›ë¦¬

## ğŸ¬ ë‹¨ê³„ë³„ ë™ì‘ ê³¼ì •

```
1ï¸âƒ£ ì‹œì‘ ë…¸ë“œë¥¼ íì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬
2ï¸âƒ£ íì—ì„œ ë…¸ë“œë¥¼ í•˜ë‚˜ êº¼ëƒ„
3ï¸âƒ£ êº¼ë‚¸ ë…¸ë“œì˜ ì¸ì ‘ ë…¸ë“œ ì¤‘ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë¥¼ ëª¨ë‘ íì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬
4ï¸âƒ£ íê°€ ë¹Œ ë•Œê¹Œì§€ 2~3ë²ˆ ë°˜ë³µ
```

## ğŸ¨ ì‹œê°ì  í‘œí˜„ (ASCII ë‹¤ì´ì–´ê·¸ë¨)

```
ê·¸ë˜í”„ ì˜ˆì‹œ:
     1
    / \
   2   3
  / \   \
 4   5   6

íƒìƒ‰ ìˆœì„œ:
Level 0: [1]
Level 1: [2, 3]
Level 2: [4, 5, 6]

í ìƒíƒœ ë³€í™”:
Step 1: Queue = [1]          Visited = {1}
Step 2: Queue = [2, 3]       Visited = {1, 2, 3}
Step 3: Queue = [3, 4, 5]    Visited = {1, 2, 3, 4, 5}
Step 4: Queue = [4, 5, 6]    Visited = {1, 2, 3, 4, 5, 6}
Step 5: Queue = [5, 6]       Visited = {1, 2, 3, 4, 5, 6}
Step 6: Queue = [6]          Visited = {1, 2, 3, 4, 5, 6}
Step 7: Queue = []           Visited = {1, 2, 3, 4, 5, 6}
```

## ğŸ“Š Mermaid ë‹¤ì´ì–´ê·¸ë¨

```
graph TD
    A[ì‹œì‘: íì— ì‹œì‘ ë…¸ë“œ ì‚½ì…] --> B[íê°€ ë¹„ì–´ìˆëŠ”ê°€?]
    B -->|ì˜ˆ| C[ì¢…ë£Œ]
    B -->|ì•„ë‹ˆì˜¤| D[íì—ì„œ ë…¸ë“œ êº¼ë‚´ê¸°]
    D --> E[í˜„ì¬ ë…¸ë“œ ì²˜ë¦¬]
    E --> F[ì¸ì ‘ ë…¸ë“œ í™•ì¸]
    F --> G[ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ ë…¸ë“œë¥¼<br/>íì— ì¶”ê°€]
    G --> H[ë°©ë¬¸ ì²˜ë¦¬]
    H --> B
    
    style A fill:#e1f5ff
    style C fill:#ffe1e1
    style D fill:#fff4e1
    style E fill:#e1ffe1
```

## ğŸ”„ íƒìƒ‰ ê³¼ì • ì• ë‹ˆë©”ì´ì…˜ (ë‹¨ê³„ë³„)

### Step 1: ì´ˆê¸° ìƒíƒœ

```
Queue: [1]
Visited: {1}
Current: -

     (1)
    /   \
   2     3
  / \     \
 4   5     6
```

### Step 2: ë…¸ë“œ 1 ë°©ë¬¸

```
Queue: [2, 3]
Visited: {1, 2, 3}
Current: 1

     [1]
    /   \
  (2)   (3)
  / \     \
 4   5     6
```

### Step 3: ë…¸ë“œ 2 ë°©ë¬¸

```
Queue: [3, 4, 5]
Visited: {1, 2, 3, 4, 5}
Current: 2

     [1]
    /   \
  [2]   (3)
  / \     \
(4) (5)    6
```

### Step 4: ë…¸ë“œ 3 ë°©ë¬¸

```
Queue: [4, 5, 6]
Visited: {1, 2, 3, 4, 5, 6}
Current: 3

     [1]
    /   \
  [2]   [3]
  / \     \
(4) (5)   (6)
```

**ë²”ë¡€:**
- `( )` : íì— ëŒ€ê¸° ì¤‘
- `\[ \]` : ë°©ë¬¸ ì™„ë£Œ
- ìˆ«ì : ë¯¸ë°©ë¬¸
---

# ğŸ“¦ í(Queue)ì˜ ì—­í• 

## ğŸ¯ ì™œ íë¥¼ ì‚¬ìš©í• ê¹Œ?

BFSëŠ” **FIFO (First In First Out)** ì›ì¹™ì„ ë”°ë¦…ë‹ˆë‹¤. ë¨¼ì € ë°œê²¬í•œ ë…¸ë“œë¥¼ ë¨¼ì € íƒìƒ‰í•´ì•¼ ë ˆë²¨ ìˆœì„œë¥¼ ë³´ì¥í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

## ğŸ“Š í vs ìŠ¤íƒ ë¹„êµ

```
graph LR
    subgraph "Queue (BFS)"
        Q1[ì•] --> Q2[2] --> Q3[3] --> Q4[4] --> Q5[ë’¤]
        Q5 -.ì…ë ¥.-> Q5
        Q1 -.ì¶œë ¥.-> Q1
    end
    
    subgraph "Stack (DFS)"
        S1[ë°‘] --> S2[2] --> S3[3] --> S4[4] --> S5[ìœ„]
        S5 -.ì…ë ¥/ì¶œë ¥.-> S5
    end
```

## ğŸ”§ í êµ¬í˜„ ë°©ë²•

### Python - `collections.deque`

```
from collections import deque

queue = deque()
queue.append(1)      # ë’¤ì— ì¶”ê°€
node = queue.popleft()  # ì•ì—ì„œ ì œê±°
```

### C# - `Queue\<T\>`

```
using System.Collections.Generic;

Queue<int> queue = new Queue<int>();
queue.Enqueue(1);    // ë’¤ì— ì¶”ê°€
int node = queue.Dequeue();  // ì•ì—ì„œ ì œê±°
```

### C++ - `std::queue`

```
#include <queue>

std::queue<int> queue;
queue.push(1);       // ë’¤ì— ì¶”ê°€
int node = queue.front();  // ì• í™•ì¸
queue.pop();         // ì•ì—ì„œ ì œê±°
```

### Java - `LinkedList` (Queue ì¸í„°í˜ì´ìŠ¤)

```
import java.util.Queue;
import java.util.LinkedList;

Queue<Integer> queue = new LinkedList<>();
queue.offer(1);      // ë’¤ì— ì¶”ê°€
int node = queue.poll();  // ì•ì—ì„œ ì œê±°
```

---

# ğŸ“ ì˜ì‚¬ì½”ë“œ(Pseudocode)

## ê¸°ë³¸ BFS ì˜ì‚¬ì½”ë“œ

```
BFS(graph, start_node):
    create empty queue Q
    create empty set visited
    
    Q.enqueue(start_node)
    visited.add(start_node)
    
    while Q is not empty:
        current = Q.dequeue()
        
        // í˜„ì¬ ë…¸ë“œ ì²˜ë¦¬
        process(current)
        
        // ì¸ì ‘ ë…¸ë“œ íƒìƒ‰
        for each neighbor of current in graph:
            if neighbor not in visited:
                visited.add(neighbor)
                Q.enqueue(neighbor)
```

## ìµœë‹¨ ê±°ë¦¬ ì¶”ì  BFS

```
BFS_with_distance(graph, start_node):
    create empty queue Q
    create distance map (node -> distance)
    
    Q.enqueue(start_node)
    distance[start_node] = 0
    
    while Q is not empty:
        current = Q.dequeue()
        current_dist = distance[current]
        
        for each neighbor of current in graph:
            if neighbor not in distance:
                distance[neighbor] = current_dist + 1
                Q.enqueue(neighbor)
    
    return distance
```

## ê²½ë¡œ ì¶”ì  BFS

```
BFS_with_path(graph, start, goal):
    create empty queue Q
    create parent map (node -> parent_node)
    
    Q.enqueue(start)
    parent[start] = null
    
    while Q is not empty:
        current = Q.dequeue()
        
        if current == goal:
            return reconstruct_path(parent, start, goal)
        
        for each neighbor of current in graph:
            if neighbor not in parent:
                parent[neighbor] = current
                Q.enqueue(neighbor)
    
    return null  // ê²½ë¡œ ì—†ìŒ

reconstruct_path(parent, start, goal):
    path = []
    current = goal
    
    while current != null:
        path.prepend(current)
        current = parent[current]
    
    return path
```

---

# ğŸ’» ë‹¤ì–‘í•œ ì–¸ì–´ êµ¬í˜„

## ğŸ Python êµ¬í˜„

### ê¸°ë³¸ BFS (ì¸ì ‘ ë¦¬ìŠ¤íŠ¸)

```
from collections import deque
from typing import List, Dict, Set

def bfs(graph: Dict[int, List[int]], start: int) -> List[int]:
    """
    BFS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
    
    Args:
        graph: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
        start: ì‹œì‘ ë…¸ë“œ
    
    Returns:
        ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸
    """
    visited: Set[int] = set()
    queue: deque = deque([start])
    result: List[int] = []
    
    visited.add(start)
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        # ì¸ì ‘ ë…¸ë“œ íƒìƒ‰
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result

# ì‚¬ìš© ì˜ˆì œ
if __name__ == "__main__":
    # ê·¸ë˜í”„ ì •ì˜
    graph = {
        1: [2, 3],
        2: [1, 4, 5],
        3: [1, 6],
        4: [2],
        5: [2],
        6: [3]
    }
    
    result = bfs(graph, 1)
    print(f"BFS íƒìƒ‰ ê²°ê³¼: {result}")
    # ì¶œë ¥: BFS íƒìƒ‰ ê²°ê³¼: [1, 2, 3, 4, 5, 6]
```

### ìµœë‹¨ ê±°ë¦¬ ê³„ì‚° BFS

```
from collections import deque
from typing import Dict, List, Optional

def bfs_shortest_path(graph: Dict[int, List[int]], 
                       start: int, 
                       goal: int) -> Optional[List[int]]:
    """
    BFSë¥¼ ì‚¬ìš©í•˜ì—¬ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°
    
    Args:
        graph: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
        start: ì‹œì‘ ë…¸ë“œ
        goal: ëª©í‘œ ë…¸ë“œ
    
    Returns:
        ìµœë‹¨ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸ (ê²½ë¡œê°€ ì—†ìœ¼ë©´ None)
    """
    if start == goal:
        return [start]
    
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        node, path = queue.popleft()
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                new_path = path + [neighbor]
                
                if neighbor == goal:
                    return new_path
                
                visited.add(neighbor)
                queue.append((neighbor, new_path))
    
    return None

# ì‚¬ìš© ì˜ˆì œ
graph = {
    1: [2, 3],
    2: [1, 4, 5],
    3: [1, 6],
    4: [2, 7],
    5: [2],
    6: [3, 7],
    7: [4, 6]
}

path = bfs_shortest_path(graph, 1, 7)
if path:
    print(f"ìµœë‹¨ ê²½ë¡œ: {' -> '.join(map(str, path))}")
    print(f"ê±°ë¦¬: {len(path) - 1}")
# ì¶œë ¥:
# ìµœë‹¨ ê²½ë¡œ: 1 -> 2 -> 4 -> 7
# ê±°ë¦¬: 3
```

### ê·¸ë¦¬ë“œ(2D ë°°ì—´) BFS

```
from collections import deque
from typing import List, Tuple, Set

def bfs_grid(grid: List[List[int]], 
             start: Tuple[int, int], 
             goal: Tuple[int, int]) -> int:
    """
    2D ê·¸ë¦¬ë“œì—ì„œ BFSë¡œ ìµœë‹¨ ê±°ë¦¬ ì°¾ê¸°
    0: ì´ë™ ê°€ëŠ¥, 1: ë²½
    
    Args:
        grid: 2D ê·¸ë¦¬ë“œ
        start: ì‹œì‘ ì¢Œí‘œ (row, col)
        goal: ëª©í‘œ ì¢Œí‘œ (row, col)
    
    Returns:
        ìµœë‹¨ ê±°ë¦¬ (ê²½ë¡œê°€ ì—†ìœ¼ë©´ -1)
    """
    rows, cols = len(grid), len(grid[0])
    
    # ìƒí•˜ì¢Œìš° ì´ë™
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)
    visited: Set[Tuple[int, int]] = {start}
    
    while queue:
        row, col, dist = queue.popleft()
        
        # ëª©í‘œ ë„ë‹¬
        if (row, col) == goal:
            return dist
        
        # 4ë°©í–¥ íƒìƒ‰
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            # ë²”ìœ„ ì²´í¬
            if 0 <= new_row < rows and 0 <= new_col < cols:
                # ë²½ì´ ì•„ë‹ˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ìš°
                if grid[new_row][new_col] == 0 and (new_row, new_col) not in visited:
                    visited.add((new_row, new_col))
                    queue.append((new_row, new_col, dist + 1))
    
    return -1  # ê²½ë¡œ ì—†ìŒ

# ì‚¬ìš© ì˜ˆì œ
if __name__ == "__main__":
    maze = [
        [0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 1, 1, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 0, 1, 0]
    ]
    
    distance = bfs_grid(maze, (0, 0), (4, 4))
    print(f"ìµœë‹¨ ê±°ë¦¬: {distance}")
    # ì¶œë ¥: ìµœë‹¨ ê±°ë¦¬: 8
```

## ğŸ”· C# êµ¬í˜„

### ê¸°ë³¸ BFS

```
using System;
using System.Collections.Generic;
using System.Linq;

public class BFSAlgorithm
{
    /// <summary>
    /// BFS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
    /// </summary>
    /// <param name="graph">ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„</param>
    /// <param name="start">ì‹œì‘ ë…¸ë“œ</param>
    /// <returns>ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸</returns>
    public static List<int> BFS(Dictionary<int, List<int>> graph, int start)
    {
        var visited = new HashSet<int>();
        var queue = new Queue<int>();
        var result = new List<int>();
        
        queue.Enqueue(start);
        visited.Add(start);
        
        while (queue.Count > 0)
        {
            var node = queue.Dequeue();
            result.Add(node);
            
            // ì¸ì ‘ ë…¸ë“œê°€ ìˆëŠ”ì§€ í™•ì¸
            if (graph.ContainsKey(node))
            {
                foreach (var neighbor in graph[node])
                {
                    if (!visited.Contains(neighbor))
                    {
                        visited.Add(neighbor);
                        queue.Enqueue(neighbor);
                    }
                }
            }
        }
        
        return result;
    }
    
    // ì‚¬ìš© ì˜ˆì œ
    public static void Main()
    {
        var graph = new Dictionary<int, List<int>>
        {
            { 1, new List<int> { 2, 3 } },
            { 2, new List<int> { 1, 4, 5 } },
            { 3, new List<int> { 1, 6 } },
            { 4, new List<int> { 2 } },
            { 5, new List<int> { 2 } },
            { 6, new List<int> { 3 } }
        };
        
        var result = BFS(graph, 1);
        Console.WriteLine($"BFS íƒìƒ‰ ê²°ê³¼: {string.Join(", ", result)}");
        // ì¶œë ¥: BFS íƒìƒ‰ ê²°ê³¼: 1, 2, 3, 4, 5, 6
    }
}
```

### Unityìš© BFS (Grid Pathfinding)

```
using UnityEngine;
using System.Collections.Generic;

public class UnityBFSPathfinding : MonoBehaviour
{
    private struct Cell
    {
        public int Row;
        public int Col;
        public int Distance;
        
        public Cell(int row, int col, int distance)
        {
            Row = row;
            Col = col;
            Distance = distance;
        }
    }
    
    /// <summary>
    /// Unity ê·¸ë¦¬ë“œì—ì„œ BFS ê²½ë¡œ ì°¾ê¸°
    /// </summary>
    /// <param name="grid">2D ê·¸ë¦¬ë“œ (true: ì´ë™ ê°€ëŠ¥, false: ë²½)</param>
    /// <param name="start">ì‹œì‘ ìœ„ì¹˜</param>
    /// <param name="goal">ëª©í‘œ ìœ„ì¹˜</param>
    /// <returns>ìµœë‹¨ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸</returns>
    public List<Vector2Int> FindPath(bool[,] grid, Vector2Int start, Vector2Int goal)
    {
        var rows = grid.GetLength(0);
        var cols = grid.GetLength(1);
        
        // 4ë°©í–¥ ì´ë™ (ìƒí•˜ì¢Œìš°)
        var directions = new Vector2Int[]
        {
            new Vector2Int(0, 1),   // ì˜¤ë¥¸ìª½
            new Vector2Int(1, 0),   // ì•„ë˜
            new Vector2Int(0, -1),  // ì™¼ìª½
            new Vector2Int(-1, 0)   // ìœ„
        };
        
        var queue = new Queue<Cell>();
        var visited = new HashSet<Vector2Int>();
        var parent = new Dictionary<Vector2Int, Vector2Int>();
        
        queue.Enqueue(new Cell(start.x, start.y, 0));
        visited.Add(start);
        parent[start] = start;
        
        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            var currentPos = new Vector2Int(current.Row, current.Col);
            
            // ëª©í‘œ ë„ë‹¬
            if (currentPos == goal)
            {
                return ReconstructPath(parent, start, goal);
            }
            
            // 4ë°©í–¥ íƒìƒ‰
            foreach (var dir in directions)
            {
                var newRow = current.Row + dir.x;
                var newCol = current.Col + dir.y;
                var newPos = new Vector2Int(newRow, newCol);
                
                // ë²”ìœ„ ì²´í¬
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols)
                {
                    // ì´ë™ ê°€ëŠ¥í•˜ê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ìš°
                    if (grid[newRow, newCol] && !visited.Contains(newPos))
                    {
                        visited.Add(newPos);
                        parent[newPos] = currentPos;
                        queue.Enqueue(new Cell(newRow, newCol, current.Distance + 1));
                    }
                }
            }
        }
        
        return null; // ê²½ë¡œ ì—†ìŒ
    }
    
    /// <summary>
    /// ë¶€ëª¨ ë§µì„ ì‚¬ìš©í•˜ì—¬ ê²½ë¡œ ì¬êµ¬ì„±
    /// </summary>
    private List<Vector2Int> ReconstructPath(Dictionary<Vector2Int, Vector2Int> parent, 
                                              Vector2Int start, 
                                              Vector2Int goal)
    {
        var path = new List<Vector2Int>();
        var current = goal;
        
        while (current != start)
        {
            path.Add(current);
            current = parent[current];
        }
        
        path.Add(start);
        path.Reverse();
        
        return path;
    }
    
    // Unity ì—ë””í„°ì—ì„œ ê²½ë¡œ ì‹œê°í™”
    private void OnDrawGizmos()
    {
        // ê²½ë¡œê°€ ìˆë‹¤ë©´ ì„ ìœ¼ë¡œ ê·¸ë¦¬ê¸°
        // (ì‹¤ì œ ì‚¬ìš© ì‹œ êµ¬í˜„)
    }
}

```

## ğŸ”µ C++ êµ¬í˜„

### ê¸°ë³¸ BFS

```
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>
#include <unordered_map>

using namespace std;

/**
 * BFS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
 * @param graph ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
 * @param start ì‹œì‘ ë…¸ë“œ
 * @return ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë…¸ë“œ ë²¡í„°
 */
vector<int> bfs(unordered_map<int, vector<int>>& graph, int start) {
    unordered_set<int> visited;
    queue<int> q;
    vector<int> result;
    
    q.push(start);
    visited.insert(start);
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        
        // ì¸ì ‘ ë…¸ë“œ íƒìƒ‰
        if (graph.find(node) != graph.end()) {
            for (int neighbor : graph[node]) {
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
    }
    
    return result;
}

// ì‚¬ìš© ì˜ˆì œ
int main() {
    // ê·¸ë˜í”„ ì •ì˜
    unordered_map<int, vector<int>> graph;
    graph[1] = {2, 3};
    graph[2] = {1, 4, 5};
    graph[3] = {1, 6};
    graph[4] = {2};
    graph[5] = {2};
    graph[6] = {3};
    
    vector<int> result = bfs(graph, 1);
    
    cout << "BFS íƒìƒ‰ ê²°ê³¼: ";
    for (int node : result) {
        cout << node << " ";
    }
    cout << endl;
    // ì¶œë ¥: BFS íƒìƒ‰ ê²°ê³¼: 1 2 3 4 5 6
    
    return 0;
}
```

### ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°

```
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <climits>

using namespace std;

/**
 * BFSë¥¼ ì‚¬ìš©í•œ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
 * @param graph ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
 * @param start ì‹œì‘ ë…¸ë“œ
 * @return ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ë§µ
 */
unordered_map<int, int> bfs_shortest_distance(unordered_map<int, vector<int>>& graph, int start) {
    unordered_map<int, int> distance;
    queue<int> q;
    
    q.push(start);
    distance[start] = 0;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        int current_dist = distance[node];
        
        if (graph.find(node) != graph.end()) {
            for (int neighbor : graph[node]) {
                if (distance.find(neighbor) == distance.end()) {
                    distance[neighbor] = current_dist + 1;
                    q.push(neighbor);
                }
            }
        }
    }
    
    return distance;
}

int main() {
    unordered_map<int, vector<int>> graph;
    graph[1] = {2, 3};
    graph[2] = {1, 4, 5};
    graph[3] = {1, 6};
    graph[4] = {2, 7};
    graph[5] = {2};
    graph[6] = {3, 7};
    graph[7] = {4, 6};
    
    auto distances = bfs_shortest_distance(graph, 1);
    
    cout << "ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬:\n";
    for (auto& [node, dist] : distances) {
        cout << "ë…¸ë“œ " << node << ": " << dist << "\n";
    }
    
    return 0;
}
```

## â˜• Java êµ¬í˜„

### ê¸°ë³¸ BFS

```
import java.util.*;

public class BFSAlgorithm {
    
    /**
     * BFS ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
     * @param graph ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„ëœ ê·¸ë˜í”„
     * @param start ì‹œì‘ ë…¸ë“œ
     * @return ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸
     */
    public static List<Integer> bfs(Map<Integer, List<Integer>> graph, int start) {
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        
        queue.offer(start);
        visited.add(start);
        
        while (!queue.isEmpty()) {
            int node = queue.poll();
            result.add(node);
            
            // ì¸ì ‘ ë…¸ë“œ íƒìƒ‰
            if (graph.containsKey(node)) {
                for (int neighbor : graph.get(node)) {
                    if (!visited.contains(neighbor)) {
                        visited.add(neighbor);
                        queue.offer(neighbor);
                    }
                }
            }
        }
        
        return result;
    }
    
    // ì‚¬ìš© ì˜ˆì œ
    public static void main(String[] args) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(1, Arrays.asList(2, 3));
        graph.put(2, Arrays.asList(1, 4, 5));
        graph.put(3, Arrays.asList(1, 6));
        graph.put(4, Arrays.asList(2));
        graph.put(5, Arrays.asList(2));
        graph.put(6, Arrays.asList(3));
        
        List<Integer> result = bfs(graph, 1);
        System.out.println("BFS íƒìƒ‰ ê²°ê³¼: " + result);
        // ì¶œë ¥: BFS íƒìƒ‰ ê²°ê³¼: [1, 2, 3, 4, 5, 6]
    }
}
```

### ê·¸ë¦¬ë“œ BFS (ìµœë‹¨ ê²½ë¡œ)

```
import java.util.*;

public class GridBFS {
    
    static class Cell {
        int row, col, distance;
        
        Cell(int row, int col, int distance) {
            this.row = row;
            this.col = col;
            this.distance = distance;
        }
    }
    
    /**
     * 2D ê·¸ë¦¬ë“œì—ì„œ BFSë¡œ ìµœë‹¨ ê±°ë¦¬ ì°¾ê¸°
     * @param grid 2D ê·¸ë¦¬ë“œ (0: ì´ë™ ê°€ëŠ¥, 1: ë²½)
     * @param start ì‹œì‘ ì¢Œí‘œ
     * @param goal ëª©í‘œ ì¢Œí‘œ
     * @return ìµœë‹¨ ê±°ë¦¬ (-1ì´ë©´ ê²½ë¡œ ì—†ìŒ)
     */
    public static int bfsGrid(int[][] grid, int[] start, int[] goal) {
        int rows = grid.length;
        int cols = grid[0].length;
        
        // 4ë°©í–¥ ì´ë™
        int[][] directions = {\{0, 1}, {1, 0}, {0, -1}, {-1, 0}\};
        
        Queue<Cell> queue = new LinkedList<>();
        boolean[][] visited = new boolean[rows][cols];
        
        queue.offer(new Cell(start[0], start[1], 0));
        visited[start[0]][start[1]] = true;
        
        while (!queue.isEmpty()) {
            Cell current = queue.poll();
            
            // ëª©í‘œ ë„ë‹¬
            if (current.row == goal[0] && current.col == goal[1]) {
                return current.distance;
            }
            
            // 4ë°©í–¥ íƒìƒ‰
            for (int[] dir : directions) {
                int newRow = current.row + dir[0];
                int newCol = current.col + dir[1];
                
                // ë²”ìœ„ ì²´í¬
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    // ë²½ì´ ì•„ë‹ˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ìš°
                    if (grid[newRow][newCol] == 0 && !visited[newRow][newCol]) {
                        visited[newRow][newCol] = true;
                        queue.offer(new Cell(newRow, newCol, current.distance + 1));
                    }
                }
            }
        }
        
        return -1; // ê²½ë¡œ ì—†ìŒ
    }
    
    public static void main(String[] args) {
        int[][] maze = {
            {0, 0, 1, 0, 0},
            {0, 0, 0, 0, 0},
            {0, 0, 1, 1, 0},
            {0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0}
        };
        
        int distance = bfsGrid(maze, new int[]{0, 0}, new int[]{4, 4});
        System.out.println("ìµœë‹¨ ê±°ë¦¬: " + distance);
        // ì¶œë ¥: ìµœë‹¨ ê±°ë¦¬: 8
    }
}
```

---

# â±ï¸ ì‹œê°„/ê³µê°„ ë³µì¡ë„ ë¶„ì„

## ğŸ“Š ì‹œê°„ ë³µì¡ë„

### **O(V + E)**

- **V**: ì •ì (Vertex)ì˜ ìˆ˜
- **E**: ê°„ì„ (Edge)ì˜ ìˆ˜

### ë¶„ì„

```
ê° ì •ì ì„ í•œ ë²ˆì”© ë°©ë¬¸: O(V)
ê° ê°„ì„ ì„ í•œ ë²ˆì”© íƒìƒ‰: O(E)

ì´ ì‹œê°„ ë³µì¡ë„: O(V + E)
```

### ê·¸ë˜í”„ í‘œí˜„ ë°©ì‹ì— ë”°ë¥¸ ì°¨ì´

```
<table header-row="true">
<tr>
<td>í‘œí˜„ ë°©ì‹</td>
<td>ì‹œê°„ ë³µì¡ë„</td>
<td>ì„¤ëª…</td>
</tr>
<tr>
<td>**ì¸ì ‘ ë¦¬ìŠ¤íŠ¸**</td>
<td>O(V + E)</td>
<td>íš¨ìœ¨ì </td>
</tr>
<tr>
<td>**ì¸ì ‘ í–‰ë ¬**</td>
<td>O(VÂ²)</td>
<td>ëª¨ë“  ì •ì ì— ëŒ€í•´ ëª¨ë“  ê°„ì„  í™•ì¸</td>
</tr>
</table>
```

## ğŸ’¾ ê³µê°„ ë³µì¡ë„

### **O(V)**

### ì‚¬ìš© ë©”ëª¨ë¦¬

1. **í(Queue)**: ìµœì•…ì˜ ê²½ìš° ëª¨ë“  ì •ì  ì €ì¥ - O(V)
2. **ë°©ë¬¸ ë°°ì—´(Visited)**: ëª¨ë“  ì •ì ì— ëŒ€í•œ ë°©ë¬¸ ì—¬ë¶€ - O(V)
3. **ê²°ê³¼ ë¦¬ìŠ¤íŠ¸**: ëª¨ë“  ì •ì  ì €ì¥ - O(V)

### ë©”ëª¨ë¦¬ ì‚¬ìš© ì˜ˆì‹œ

```
graph TD
    A["ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰"]
    B["Queue: O(V)"]
    C["Visited Set: O(V)"]
    D["Result List: O(V)"]
    E["Total: O(V)"]
    
    A --> B
    A --> C
    A --> D
    B --> E
    C --> E
    D --> E
    
    style A fill:#ffe1e1
    style E fill:#e1ffe1
```

## ğŸ” ì‹¤ì œ ì„±ëŠ¥ ë¹„êµ

### ë‹¤ì–‘í•œ ê·¸ë˜í”„ í¬ê¸°ì—ì„œì˜ ì‹¤í–‰ ì‹œê°„

```
import time
import random
from collections import deque, defaultdict

def measure_bfs_performance(num_vertices: int, num_edges: int):
    # ëœë¤ ê·¸ë˜í”„ ìƒì„±
    graph = defaultdict(list)
    for _ in range(num_edges):
        u = random.randint(0, num_vertices - 1)
        v = random.randint(0, num_vertices - 1)
        if u != v:
            graph[u].append(v)
    
    # BFS ì‹¤í–‰ ë° ì‹œê°„ ì¸¡ì •
    start_time = time.time()
    
    visited = set()
    queue = deque([0])
    visited.add(0)
    
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    end_time = time.time()
    elapsed = (end_time - start_time) * 1000  # ë°€ë¦¬ì´ˆ
    
    return elapsed

# ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
print("ì •ì  ìˆ˜ | ê°„ì„  ìˆ˜ | ì‹¤í–‰ ì‹œê°„ (ms)")
print("-" * 40)
for v in [100, 1000, 10000, 100000]:
    e = v * 2  # ê°„ì„  ìˆ˜ = ì •ì  ìˆ˜ * 2
    time_taken = measure_bfs_performance(v, e)
    print(f"{v:7d} | {e:7d} | {time_taken:8.3f}")
```

**ì˜ˆìƒ ì¶œë ¥:**

```
ì •ì  ìˆ˜ | ê°„ì„  ìˆ˜ | ì‹¤í–‰ ì‹œê°„ (ms)
----------------------------------------
    100 |     200 |    0.234
   1000 |    2000 |    2.156
  10000 |   20000 |   23.789
 100000 |  200000 |  267.453
```

---

# âš–ï¸ BFS vs DFS ë¹„êµ

## ğŸ“Š í•µì‹¬ ì°¨ì´ì 

```
<table header-row="true">
<tr>
<td>íŠ¹ì„±</td>
<td>BFS</td>
<td>DFS</td>
</tr>
<tr>
<td>**íƒìƒ‰ ë°©ì‹**</td>
<td>ë„ˆë¹„ ìš°ì„  (ë ˆë²¨ë³„)</td>
<td>ê¹Šì´ ìš°ì„  (ê²½ë¡œ ëê¹Œì§€)</td>
</tr>
<tr>
<td>**ìë£Œêµ¬ì¡°**</td>
<td>í (Queue)</td>
<td>ìŠ¤íƒ (Stack) / ì¬ê·€</td>
</tr>
<tr>
<td>**ì‹œê°„ ë³µì¡ë„**</td>
<td>O(V + E)</td>
<td>O(V + E)</td>
</tr>
<tr>
<td>**ê³µê°„ ë³µì¡ë„**</td>
<td>O(V)</td>
<td>O(h) - hëŠ” ìµœëŒ€ ê¹Šì´</td>
</tr>
<tr>
<td>**ìµœë‹¨ ê²½ë¡œ**</td>
<td>âœ… ë³´ì¥</td>
<td>âŒ ë³´ì¥ ì•ˆ í•¨</td>
</tr>
<tr>
<td>**ë©”ëª¨ë¦¬ ì‚¬ìš©**</td>
<td>ë„“ì€ ê·¸ë˜í”„ì—ì„œ ë§ìŒ</td>
<td>ê¹Šì€ ê·¸ë˜í”„ì—ì„œ ì ìŒ</td>
</tr>
<tr>
<td>**êµ¬í˜„ ë°©ì‹**</td>
<td>ë°˜ë³µë¬¸ (iterative)</td>
<td>ì¬ê·€ or ë°˜ë³µë¬¸</td>
</tr>
</table>
```


## ğŸ¨ ì‹œê°ì  ë¹„êµ

### BFS íƒìƒ‰ ìˆœì„œ

```
        1
       / \
      2   3
     /|   |\
    4 5   6 7
   /|
  8 9

BFS: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 â†’ 7 â†’ 8 â†’ 9
ë ˆë²¨ 0: [1]
ë ˆë²¨ 1: [2, 3]
ë ˆë²¨ 2: [4, 5, 6, 7]
ë ˆë²¨ 3: [8, 9]
```

### DFS íƒìƒ‰ ìˆœì„œ

```
        1
       / \
      2   3
     /|   |\
    4 5   6 7
   /|
  8 9

DFS: 1 â†’ 2 â†’ 4 â†’ 8 â†’ 9 â†’ 5 â†’ 3 â†’ 6 â†’ 7
ê²½ë¡œ ìš°ì„  íƒìƒ‰
```

## ğŸ”€ íƒìƒ‰ ê³¼ì • ë¹„êµ ë‹¤ì´ì–´ê·¸ë¨

```
graph TD
    subgraph "BFS - ë ˆë²¨ë³„ íƒìƒ‰"
        B1["Level 0: Start"]
        B2["Level 1: ì¸ì ‘ ë…¸ë“œ ëª¨ë‘"]
        B3["Level 2: ë‹¤ìŒ ë ˆë²¨ ëª¨ë‘"]
        B4["Level 3: ..."]
        B1 --> B2 --> B3 --> B4
    end
    
    subgraph "DFS - ê¹Šì´ ìš°ì„ "
        D1["Start"]
        D2["ì²« ë²ˆì§¸ ìì‹"]
        D3["ê·¸ ìì‹ì˜ ìì‹"]
        D4["ëê¹Œì§€ ê¹Šì´ íƒìƒ‰"]
        D5["ë°±íŠ¸ë˜í‚¹"]
        D1 --> D2 --> D3 --> D4 --> D5
    end
```

## ğŸ¯ ì–¸ì œ ì–´ë–¤ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í• ê¹Œ?

### âœ… BFSë¥¼ ì‚¬ìš©í•´ì•¼ í•  ë•Œ

1. **ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°** (ê°€ì¤‘ì¹˜ ì—†ëŠ” ê·¸ë˜í”„)
	- ì˜ˆ: ë¯¸ë¡œ ìµœë‹¨ ê²½ë¡œ, SNS ì¹œêµ¬ ì¶”ì²œ
2. **ë ˆë²¨ ìˆœì„œ íƒìƒ‰**
	- ì˜ˆ: íŠ¸ë¦¬ ë ˆë²¨ ìˆœíšŒ, ì¡°ì§ë„ ê³„ì¸µ íƒìƒ‰
3. **ìµœì†Œ ì´ë™ íšŸìˆ˜**
	- ì˜ˆ: ê²Œì„ì—ì„œ ìµœì†Œ ì´ë™, í¼ì¦ ë¬¸ì œ
4. **ë„“ê³  ì–•ì€ ê·¸ë˜í”„**
	- ì˜ˆ: ì†Œì…œ ë„¤íŠ¸ì›Œí¬, ì›¹ í¬ë¡¤ë§

### âœ… DFSë¥¼ ì‚¬ìš©í•´ì•¼ í•  ë•Œ

1. **ê²½ë¡œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸**
	- ì˜ˆ: ë¯¸ë¡œ íƒˆì¶œ ê°€ëŠ¥ ì—¬ë¶€
2. **ëª¨ë“  ê²½ë¡œ íƒìƒ‰**
	- ì˜ˆ: ë°±íŠ¸ë˜í‚¹ ë¬¸ì œ, ìˆœì—´/ì¡°í•©
3. **ì‚¬ì´í´ ê²€ì¶œ**
	- ì˜ˆ: ìˆœí™˜ ì°¸ì¡° í™•ì¸
4. **ì¢ê³  ê¹Šì€ ê·¸ë˜í”„**
	- ì˜ˆ: íŒŒì¼ ì‹œìŠ¤í…œ íƒìƒ‰

## ğŸ’¡ ì‹¤ì „ ì˜ˆì œ ë¹„êµ

### ë¬¸ì œ: ë¯¸ë¡œì—ì„œ ì¶œêµ¬ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬

```
from collections import deque

# BFS ì†”ë£¨ì…˜ (ìµœë‹¨ ê²½ë¡œ ë³´ì¥)
def bfs_maze_shortest(maze, start, end):
    queue = deque([(start, 0)])  # (ìœ„ì¹˜, ê±°ë¦¬)
    visited = {start}
    
    while queue:
        pos, dist = queue.popleft()
        if pos == end:
            return dist  # ìµœë‹¨ ê±°ë¦¬ ë³´ì¥!
        
        for next_pos in get_neighbors(pos, maze):
            if next_pos not in visited:
                visited.add(next_pos)
                queue.append((next_pos, dist + 1))
    
    return -1

# DFS ì†”ë£¨ì…˜ (ìµœë‹¨ ê²½ë¡œ ë³´ì¥ ì•ˆ ë¨)
def dfs_maze_any(maze, start, end, visited=None):
    if visited is None:
        visited = set()
    
    if start == end:
        return 0  # ê±°ë¦¬ê°€ ìµœë‹¨ì´ ì•„ë‹ ìˆ˜ ìˆìŒ
    
    visited.add(start)
    
    for next_pos in get_neighbors(start, maze):
        if next_pos not in visited:
            result = dfs_maze_any(maze, next_pos, end, visited)
            if result != -1:
                return result + 1  # ì²« ë²ˆì§¸ ê²½ë¡œ (ìµœë‹¨ ì•„ë‹˜)
    
    return -1

def get_neighbors(pos, maze):
    # ìƒí•˜ì¢Œìš° ì´ë™ ê°€ëŠ¥í•œ ìœ„ì¹˜ ë°˜í™˜
    pass
```

### ê²°ê³¼ ë¹„êµ

```
ë¯¸ë¡œ:
S . . # .
# . # . .
. . . . #
. # # . E

BFS: ìµœë‹¨ ê±°ë¦¬ = 8
DFS: ê±°ë¦¬ = 12 (ì²« ë²ˆì§¸ë¡œ ì°¾ì€ ê²½ë¡œ)
```

## ğŸ“ˆ ì„±ëŠ¥ ë¹„êµ ì°¨íŠ¸

```
graph LR
    subgraph "ê·¸ë˜í”„ í˜•íƒœë³„ ì„ í˜¸ë„"
        A["ë„“ê³  ì–•ì€ ê·¸ë˜í”„"] -.BFS ìœ ë¦¬.-> B["O(V) ë©”ëª¨ë¦¬"]
        C["ì¢ê³  ê¹Šì€ ê·¸ë˜í”„"] -.DFS ìœ ë¦¬.-> D["O(h) ë©”ëª¨ë¦¬"]
    end
    
    subgraph "ë¬¸ì œ ìœ í˜•ë³„ ì„ íƒ"
        E["ìµœë‹¨ ê²½ë¡œ"] --> F["BFS"]
        G["ê²½ë¡œ ì¡´ì¬ ì—¬ë¶€"] --> H["DFS"]
        I["ëª¨ë“  ê²½ë¡œ íƒìƒ‰"] --> H
        J["ë ˆë²¨ ìˆœíšŒ"] --> F
    end
```

---

# ğŸš€ ì‘ìš© ë¶„ì•¼

BFSëŠ” ë‹¤ì–‘í•œ ì‹¤ì „ ë¬¸ì œì—ì„œ í™œìš©ë©ë‹ˆë‹¤. ê° ì‘ìš© ë¶„ì•¼ë¥¼ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

## 1ï¸âƒ£ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” ê·¸ë˜í”„ì—ì„œ ë‘ ë…¸ë“œ ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

### ğŸ’» ì½”ë“œ ì˜ˆì œ

```
from collections import deque
from typing import List, Optional, Dict

def shortest_path(graph: Dict[int, List[int]], start: int, goal: int) -> Optional[List[int]]:
    """
    BFSë¥¼ ì‚¬ìš©í•œ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°
    """
    if start == goal:
        return [start]
    
    queue = deque([start])
    visited = {start}
    parent = {start: None}
    
    while queue:
        node = queue.popleft()
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = node
                queue.append(neighbor)
                
                # ëª©í‘œ ë„ë‹¬
                if neighbor == goal:
                    # ê²½ë¡œ ì¬êµ¬ì„±
                    path = []
                    current = goal
                    while current is not None:
                        path.append(current)
                        current = parent[current]
                    return path[::-1]
    
    return None  # ê²½ë¡œ ì—†ìŒ

# ì‚¬ìš© ì˜ˆì œ
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

path = shortest_path(graph, 'A', 'F')
print(f"ìµœë‹¨ ê²½ë¡œ: {' -> '.join(path)}")
# ì¶œë ¥: ìµœë‹¨ ê²½ë¡œ: A -> C -> F
```

## 2ï¸âƒ£ ë ˆë²¨ ìˆœíšŒ (Level Order Traversal)

### ğŸ“ ë¬¸ì œ ì„¤ëª…

íŠ¸ë¦¬ì˜ ê° ë ˆë²¨ë³„ë¡œ ë…¸ë“œë¥¼ ìˆœíšŒí•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

### ğŸ’» ì½”ë“œ ì˜ˆì œ

```
from collections import deque
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]:
    """
    ì´ì§„ íŠ¸ë¦¬ ë ˆë²¨ ìˆœíšŒ
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        # í˜„ì¬ ë ˆë²¨ì˜ ëª¨ë“  ë…¸ë“œ ì²˜ë¦¬
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            # ìì‹ ë…¸ë“œë¥¼ íì— ì¶”ê°€
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result

# ì‚¬ìš© ì˜ˆì œ
#       3
#      / \
#     9  20
#       /  \
#      15   7

root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

result = level_order_traversal(root)
print("ë ˆë²¨ë³„ ìˆœíšŒ:", result)
# ì¶œë ¥: ë ˆë²¨ë³„ ìˆœíšŒ: [[3], [9, 20], [15, 7]]
```

## 3ï¸âƒ£ ë¯¸ë¡œ íƒìƒ‰

### ğŸ“ ë¬¸ì œ ì„¤ëª…

2D ê·¸ë¦¬ë“œì—ì„œ ì‹œì‘ì ë¶€í„° ë„ì°©ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

### ğŸ’» ì½”ë“œ ì˜ˆì œ

```
from collections import deque
from typing import List, Tuple

def solve_maze(maze: List[List[int]], 
               start: Tuple[int, int], 
               end: Tuple[int, int]) -> int:
    """
    ë¯¸ë¡œ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°
    0: í†µë¡œ, 1: ë²½
    """
    rows, cols = len(maze), len(maze[0])
    
    # 4ë°©í–¥ ì´ë™ (ìƒí•˜ì¢Œìš°)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)
    visited = {start}
    
    while queue:
        row, col, dist = queue.popleft()
        
        # ë„ì°©ì  ë„ë‹¬
        if (row, col) == end:
            return dist
        
        # 4ë°©í–¥ íƒìƒ‰
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            # ë²”ìœ„ ë‚´, í†µë¡œ, ë¯¸ë°©ë¬¸
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                maze[new_row][new_col] == 0 and 
                (new_row, new_col) not in visited):
                
                visited.add((new_row, new_col))
                queue.append((new_row, new_col, dist + 1))
    
    return -1  # ê²½ë¡œ ì—†ìŒ

# ì‚¬ìš© ì˜ˆì œ
maze = [
    [0, 0, 0, 0, 1],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0],
    [0, 1, 1, 0, 0],
    [0, 0, 0, 0, 0]
]

start = (0, 0)
end = (4, 4)

distance = solve_maze(maze, start, end)
print(f"ìµœë‹¨ ê±°ë¦¬: {distance}")
# ì¶œë ¥: ìµœë‹¨ ê±°ë¦¬: 8
```

## 4ï¸âƒ£ ì†Œì…œ ë„¤íŠ¸ì›Œí¬ ë¶„ì„

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ì†Œì…œ ë„¤íŠ¸ì›Œí¬ì—ì„œ ì‚¬ìš©ì ê°„ì˜ ì—°ê²° ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

### ğŸ’» ì½”ë“œ ì˜ˆì œ

```
from collections import deque, defaultdict
from typing import Dict, List, Set

class SocialNetwork:
    def __init__(self):
        self.graph: Dict[str, Set[str]] = defaultdict(set)
    
    def add_friendship(self, user1: str, user2: str):
        """ì¹œêµ¬ ê´€ê³„ ì¶”ê°€"""
        self.graph[user1].add(user2)
        self.graph[user2].add(user1)
    
    def degrees_of_separation(self, user1: str, user2: str) -> int:
        """
        ë‘ ì‚¬ìš©ì ì‚¬ì´ì˜ ì´Œìˆ˜(degrees of separation) ê³„ì‚°
        """
        if user1 == user2:
            return 0
        
        if user1 not in self.graph or user2 not in self.graph:
            return -1
        
        queue = deque([(user1, 0)])
        visited = {user1}
        
        while queue:
            current_user, degree = queue.popleft()
            
            for friend in self.graph[current_user]:
                if friend == user2:
                    return degree + 1
                
                if friend not in visited:
                    visited.add(friend)
                    queue.append((friend, degree + 1))
        
        return -1  # ì—°ê²°ë˜ì§€ ì•ŠìŒ
    
    def find_mutual_friends(self, user1: str, user2: str) -> List[str]:
        """ê³µí†µ ì¹œêµ¬ ì°¾ê¸°"""
        if user1 not in self.graph or user2 not in self.graph:
            return []
        
        return list(self.graph[user1] & self.graph[user2])
    
    def suggest_friends(self, user: str, max_suggestions: int = 5) -> List[str]:
        """
        ì¹œêµ¬ ì¶”ì²œ (ì¹œêµ¬ì˜ ì¹œêµ¬ ì¤‘ ì•„ì§ ì¹œêµ¬ê°€ ì•„ë‹Œ ì‚¬ëŒ)
        """
        if user not in self.graph:
            return []
        
        direct_friends = self.graph[user]
        suggestions = defaultdict(int)
        
        # ì¹œêµ¬ì˜ ì¹œêµ¬ íƒìƒ‰
        for friend in direct_friends:
            for fof in self.graph[friend]:  # friend of friend
                if fof != user and fof not in direct_friends:
                    suggestions[fof] += 1
        
        # ê³µí†µ ì¹œêµ¬ ìˆ˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
        sorted_suggestions = sorted(suggestions.items(), 
                                    key=lambda x: x[1], 
                                    reverse=True)
        
        return [user for user, _ in sorted_suggestions[:max_suggestions]]

# ì‚¬ìš© ì˜ˆì œ
sn = SocialNetwork()

# ì¹œêµ¬ ê´€ê³„ ì¶”ê°€
sn.add_friendship("Alice", "Bob")
sn.add_friendship("Alice", "Charlie")
sn.add_friendship("Bob", "David")
sn.add_friendship("Charlie", "David")
sn.add_friendship("David", "Eve")
sn.add_friendship("Eve", "Frank")

# ì´Œìˆ˜ ê³„ì‚°
degree = sn.degrees_of_separation("Alice", "Frank")
print(f"Aliceì™€ Frankì˜ ì´Œìˆ˜: {degree}")
# ì¶œë ¥: Aliceì™€ Frankì˜ ì´Œìˆ˜: 4

# ê³µí†µ ì¹œêµ¬
mutual = sn.find_mutual_friends("Bob", "Charlie")
print(f"Bobê³¼ Charlieì˜ ê³µí†µ ì¹œêµ¬: {mutual}")
# ì¶œë ¥: Bobê³¼ Charlieì˜ ê³µí†µ ì¹œêµ¬: ['Alice', 'David']

# ì¹œêµ¬ ì¶”ì²œ
suggestions = sn.suggest_friends("Alice")
print(f"Aliceì—ê²Œ ì¶”ì²œí•  ì¹œêµ¬: {suggestions}")
# ì¶œë ¥: Aliceì—ê²Œ ì¶”ì²œí•  ì¹œêµ¬: ['David']
```

## 5ï¸âƒ£ ê²Œì„ AI (ê¸¸ì°¾ê¸°)

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ê²Œì„ì—ì„œ NPCê°€ ì¥ì• ë¬¼ì„ í”¼í•´ ëª©í‘œ ì§€ì ê¹Œì§€ ì´ë™í•˜ëŠ” ê²½ë¡œë¥¼ ì°¾ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

### ğŸ’» ì½”ë“œ ì˜ˆì œ

```
from collections import deque
from typing import List, Tuple, Optional

class GamePathfinding:
    def __init__(self, grid: List[List[int]]):
        """
        grid: 0 = ì´ë™ ê°€ëŠ¥, 1 = ì¥ì• ë¬¼
        """
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0])
    
    def find_path(self, start: Tuple[int, int], 
                  goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]:
        """
        BFSë¥¼ ì‚¬ìš©í•œ ê²½ë¡œ ì°¾ê¸°
        """
        # 4ë°©í–¥ ì´ë™
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        direction_names = ['â†’', 'â†“', 'â†', 'â†‘']
        
        queue = deque([start])
        visited = {start}
        parent = {start: None}
        
        while queue:
            current = queue.popleft()
            
            if current == goal:
                # ê²½ë¡œ ì¬êµ¬ì„±
                path = []
                node = goal
                while node is not None:
                    path.append(node)
                    node = parent[node]
                return path[::-1]
            
            row, col = current
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                new_pos = (new_row, new_col)
                
                # ìœ íš¨í•œ ì´ë™ì¸ì§€ í™•ì¸
                if (0 <= new_row < self.rows and 
                    0 <= new_col < self.cols and 
                    self.grid[new_row][new_col] == 0 and 
                    new_pos not in visited):
                    
                    visited.add(new_pos)
                    parent[new_pos] = current
                    queue.append(new_pos)
        
        return None  # ê²½ë¡œ ì—†ìŒ
    
    def visualize_path(self, path: List[Tuple[int, int]]):
        """
        ê²½ë¡œ ì‹œê°í™”
        """
        # ê·¸ë¦¬ë“œ ë³µì‚¬
        visual = [row[:] for row in self.grid]
        
        # ê²½ë¡œ í‘œì‹œ
        for i, (row, col) in enumerate(path):
            if i == 0:
                visual[row][col] = 'S'  # Start
            elif i == len(path) - 1:
                visual[row][col] = 'G'  # Goal
            else:
                visual[row][col] = '*'  # Path
        
        # ì¶œë ¥
        for row in visual:
            print(' '.join(str(cell) if cell != 1 else 'â–ˆ' for cell in row))

# ì‚¬ìš© ì˜ˆì œ
grid = [
    [0, 0, 0, 0, 1, 0],
    [0, 1, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 0, 0]
]

pathfinding = GamePathfinding(grid)
path = pathfinding.find_path((0, 0), (4, 5))

if path:
    print(f"ê²½ë¡œ ê¸¸ì´: {len(path)}")
    print("\nê²½ë¡œ ì‹œê°í™”:")
    pathfinding.visualize_path(path)
else:
    print("ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

# ì¶œë ¥:
# ê²½ë¡œ ê¸¸ì´: 11
#
# ê²½ë¡œ ì‹œê°í™”:
# S * * * â–ˆ 0
# 0 â–ˆ â–ˆ * â–ˆ 0
# 0 0 0 * * *
# 0 â–ˆ â–ˆ â–ˆ â–ˆ *
# 0 0 0 0 0 G
```

## 6ï¸âƒ£ ì›¹ í¬ë¡¤ë§

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ì›¹ í˜ì´ì§€ì˜ ë§í¬ë¥¼ ë”°ë¼ê°€ë©° íŠ¹ì • ê¹Šì´ê¹Œì§€ í˜ì´ì§€ë¥¼ ìˆ˜ì§‘í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

### ğŸ’» ì½”ë“œ ì˜ˆì œ

```
from collections import deque
from typing import Set, List, Dict
import re
from urllib.parse import urljoin, urlparse

class WebCrawler:
    def __init__(self, max_depth: int = 3):
        self.max_depth = max_depth
        self.visited: Set[str] = set()
    
    def crawl(self, start_url: str) -> Dict[int, List[str]]:
        """
        BFSë¥¼ ì‚¬ìš©í•œ ì›¹ í¬ë¡¤ë§
        """
        result = {}
        queue = deque([(start_url, 0)])  # (url, depth)
        self.visited.add(start_url)
        
        while queue:
            url, depth = queue.popleft()
            
            # ê¹Šì´ ì œí•œ
            if depth > self.max_depth:
                continue
            
            # í˜„ì¬ ê¹Šì´ì— URL ì¶”ê°€
            if depth not in result:
                result[depth] = []
            result[depth].append(url)
            
            # ë§í¬ ì¶”ì¶œ (ì‹¤ì œë¡œëŠ” HTML íŒŒì‹± í•„ìš”)
            links = self.extract_links(url)
            
            for link in links:
                if link not in self.visited:
                    self.visited.add(link)
                    queue.append((link, depth + 1))
        
        return result
    
    def extract_links(self, url: str) -> List[str]:
        """
        í˜ì´ì§€ì—ì„œ ë§í¬ ì¶”ì¶œ (ì‹œë®¬ë ˆì´ì…˜)
        ì‹¤ì œë¡œëŠ” requests + BeautifulSoup ì‚¬ìš©
        """
        # ì‹œë®¬ë ˆì´ì…˜ìš© ë”ë¯¸ ë°ì´í„°
        dummy_links = {
            "
```

---

# ğŸ® Unity ê²Œì„ ê°œë°œ í™œìš©

Unity ê²Œì„ ê°œë°œì—ì„œ BFSëŠ” NPC AI, ê¸¸ì°¾ê¸°, íƒ€ì›Œ ë””íœìŠ¤ ë“± ë‹¤ì–‘í•œ ë¶„ì•¼ì—ì„œ í™œìš©ë©ë‹ˆë‹¤.

## ğŸ—ºï¸ Unity Grid Pathfinding

### C# êµ¬í˜„

```
using UnityEngine;
using System.Collections.Generic;

public class UnityBFSPathfinder : MonoBehaviour
{
    [System.Serializable]
    public class GridCell
    {
        public Vector2Int Position;
        public bool IsWalkable;
        public GameObject VisualObject;
    }
    
    [Header("Grid Settings")]
    public int gridWidth = 10;
    public int gridHeight = 10;
    public float cellSize = 1f;
    
    [Header("Prefabs")]
    public GameObject walkableCellPrefab;
    public GameObject obstacleCellPrefab;
    public GameObject pathMarkerPrefab;
    
    private GridCell[,] grid;
    private List<GameObject> pathMarkers = new List<GameObject>();
    
    void Start()
    {
        InitializeGrid();
    }
    
    /// <summary>
    /// ê·¸ë¦¬ë“œ ì´ˆê¸°í™”
    /// </summary>
    void InitializeGrid()
    {
        grid = new GridCell[gridWidth, gridHeight];
        
        for (int x = 0; x < gridWidth; x++)
        {
            for (int y = 0; y < gridHeight; y++)
            {
                var cell = new GridCell
                {
                    Position = new Vector2Int(x, y),
                    IsWalkable = Random.value > 0.3f // 30% í™•ë¥ ë¡œ ì¥ì• ë¬¼
                };
                
                // ì‹œê°ì  í‘œí˜„
                var prefab = cell.IsWalkable ? walkableCellPrefab : obstacleCellPrefab;
                var worldPos = new Vector3(x * cellSize, 0, y * cellSize);
                cell.VisualObject = Instantiate(prefab, worldPos, Quaternion.identity, transform);
                
                grid[x, y] = cell;
            }
        }
    }
    
    /// <summary>
    /// BFS ê²½ë¡œ ì°¾ê¸°
    /// </summary>
    public List<Vector2Int> FindPath(Vector2Int start, Vector2Int goal)
    {
        if (!IsValidCell(start) || !IsValidCell(goal))
            return null;
        
        if (!grid[start.x, start.y].IsWalkable || !grid[goal.x, goal.y].IsWalkable)
            return null;
        
        // BFS ì´ˆê¸°í™”
        var queue = new Queue<Vector2Int>();
        var visited = new HashSet<Vector2Int>();
        var parent = new Dictionary<Vector2Int, Vector2Int>();
        
        queue.Enqueue(start);
        visited.Add(start);
        parent[start] = start;
        
        // 4ë°©í–¥ ì´ë™
        Vector2Int[] directions = new Vector2Int[]
        {
            new Vector2Int(0, 1),   // ìœ„
            new Vector2Int(1, 0),   // ì˜¤ë¥¸ìª½
            new Vector2Int(0, -1),  // ì•„ë˜
            new Vector2Int(-1, 0)   // ì™¼ìª½
        };
        
        // BFS íƒìƒ‰
        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            
            if (current == goal)
            {
                return ReconstructPath(parent, start, goal);
            }
            
            // ì¸ì ‘ ì…€ íƒìƒ‰
            foreach (var dir in directions)
            {
                var next = current + dir;
                
                if (IsValidCell(next) && 
                    grid[next.x, next.y].IsWalkable && 
                    !visited.Contains(next))
                {
                    visited.Add(next);
                    parent[next] = current;
                    queue.Enqueue(next);
                }
            }
        }
        
        return null; // ê²½ë¡œ ì—†ìŒ
    }
    
    /// <summary>
    /// ê²½ë¡œ ì¬êµ¬ì„±
    /// </summary>
    private List<Vector2Int> ReconstructPath(Dictionary<Vector2Int, Vector2Int> parent, 
                                              Vector2Int start, 
                                              Vector2Int goal)
    {
        var path = new List<Vector2Int>();
        var current = goal;
        
        while (current != start)
        {
            path.Add(current);
            current = parent[current];
        }
        
        path.Add(start);
        path.Reverse();
        
        return path;
    }
    
    /// <summary>
    /// ìœ íš¨í•œ ì…€ì¸ì§€ í™•ì¸
    /// </summary>
    private bool IsValidCell(Vector2Int pos)
    {
        return pos.x >= 0 && pos.x < gridWidth && 
               pos.y >= 0 && pos.y < gridHeight;
    }
    
    /// <summary>
    /// ê²½ë¡œ ì‹œê°í™”
    /// </summary>
    public void VisualizePath(List<Vector2Int> path)
    {
        // ì´ì „ ë§ˆì»¤ ì œê±°
        foreach (var marker in pathMarkers)
        {
            Destroy(marker);
        }
        pathMarkers.Clear();
        
        // ìƒˆ ê²½ë¡œ ë§ˆì»¤ ìƒì„±
        if (path != null)
        {
            foreach (var cell in path)
            {
                var worldPos = new Vector3(cell.x * cellSize, 0.5f, cell.y * cellSize);
                var marker = Instantiate(pathMarkerPrefab, worldPos, Quaternion.identity, transform);
                pathMarkers.Add(marker);
            }
        }
    }
    
    /// <summary>
    /// ì—ë””í„°ì—ì„œ ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
    /// </summary>
    void OnDrawGizmos()
    {
        if (grid == null) return;
        
        for (int x = 0; x < gridWidth; x++)
        {
            for (int y = 0; y < gridHeight; y++)
            {
                var cell = grid[x, y];
                var worldPos = new Vector3(x * cellSize, 0, y * cellSize);
                
                Gizmos.color = cell.IsWalkable ? 
</summary>
## ğŸ¤– NPC AI Movement
### C# êµ¬í˜„
```

```
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class NPCPathfollower : MonoBehaviour
{
    [Header("Movement Settings")]
    public float moveSpeed = 3f;
    public float rotationSpeed = 5f;
    public float waypointReachedDistance = 0.1f;
    
    [Header("References")]
    public UnityBFSPathfinder pathfinder;
    public Transform target;
    
    private List<Vector2Int> currentPath;
    private int currentWaypointIndex = 0;
    private bool isMoving = false;
    
    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            FindAndFollowPath();
        }
    }
    
    /// <summary>
    /// ê²½ë¡œ ì°¾ê¸° ë° ì´ë™ ì‹œì‘
    /// </summary>
    void FindAndFollowPath()
    {
        if (pathfinder == null || target == null)
            return;
        
        // í˜„ì¬ ìœ„ì¹˜ì™€ ëª©í‘œ ìœ„ì¹˜ë¥¼ ê·¸ë¦¬ë“œ ì¢Œí‘œë¡œ ë³€í™˜
        var startCell = WorldToGrid(transform.position);
        var goalCell = WorldToGrid(target.position);
        
        // ê²½ë¡œ ì°¾ê¸°
        currentPath = pathfinder.FindPath(startCell, goalCell);
        
        if (currentPath != null && currentPath.Count > 0)
        {
            currentWaypointIndex = 0;
            pathfinder.VisualizePath(currentPath);
            StartCoroutine(FollowPath());
        }
        else
        {
            Debug.Log("ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
        }
    }
    
    /// <summary>
    /// ê²½ë¡œ ë”°ë¼ ì´ë™
    /// </summary>
    IEnumerator FollowPath()
    {
        isMoving = true;
        
        while (currentWaypointIndex < currentPath.Count)
        {
            var targetCell = currentPath[currentWaypointIndex];
            var targetWorldPos = GridToWorld(targetCell);
            
            // ì›¨ì´í¬ì¸íŠ¸ë¡œ ì´ë™
            while (Vector3.Distance(transform.position, targetWorldPos) > waypointReachedDistance)
            {
                // ì´ë™
                var direction = (targetWorldPos - transform.position).normalized;
                transform.position += direction * moveSpeed * Time.deltaTime;
                
                // íšŒì „
                if (direction != 
</summary>

## ğŸ¯ íƒ€ì›Œ ë””íœìŠ¤ ì˜ˆì œ

### ì ì´ ìµœë‹¨ ê²½ë¡œë¡œ ì´ë™í•˜ëŠ” ì‹œìŠ¤í…œ

```
using UnityEngine;
using System.Collections.Generic;

public class TowerDefenseEnemy : MonoBehaviour
{
    [Header("Movement")]
    public float moveSpeed = 2f;
    
    [Header("Path")]
    private List<Vector3> pathToGoal;
    private int currentPathIndex = 0;
    
    private UnityBFSPathfinder pathfinder;
    
    void Start()
    {
        pathfinder = FindObjectOfType<UnityBFSPathfinder>();
        FindPathToGoal();
    }
    
    void Update()
    {
        if (pathToGoal != null && currentPathIndex < pathToGoal.Count)
        {
            MoveAlongPath();
        }
    }
    
    void FindPathToGoal()
    {
        var startCell = new Vector2Int(
            Mathf.RoundToInt(transform.position.x / pathfinder.cellSize),
            Mathf.RoundToInt(transform.position.z / pathfinder.cellSize)
        );
        
        // ëª©í‘œ ì§€ì  (ì˜ˆ: ë§µ ë)
        var goalCell = new Vector2Int(pathfinder.gridWidth - 1, pathfinder.gridHeight - 1);
        
        var path = pathfinder.FindPath(startCell, goalCell);
        
        if (path != null)
        {
            pathToGoal = new List<Vector3>();
            foreach (var cell in path)
            {
                pathToGoal.Add(new Vector3(
                    cell.x * pathfinder.cellSize,
                    transform.position.y,
                    cell.y * pathfinder.cellSize
                ));
            }
        }
    }
    
    void MoveAlongPath()
    {
        var targetPos = pathToGoal[currentPathIndex];
        transform.position = Vector3.MoveTowards(transform.position, targetPos, moveSpeed * Time.deltaTime);
        
        // ë°©í–¥ íšŒì „
        var direction = (targetPos - transform.position).normalized;
        if (direction != 
```

---
(ê³„ì† ì‘ì„± ì¤‘... ë‹¤ìŒ ì„¹ì…˜: ìµœì í™” ê¸°ë²•)

# âš¡ ìµœì í™” ê¸°ë²•

BFSì˜ ê¸°ë³¸ êµ¬í˜„ì€ íš¨ìœ¨ì ì´ì§€ë§Œ, íŠ¹ì • ìƒí™©ì—ì„œëŠ” ì¶”ê°€ ìµœì í™”ê°€ í•„ìš”í•©ë‹ˆë‹¤.

## ğŸ”„ ì–‘ë°©í–¥ BFS (Bidirectional BFS)

### ğŸ“ ê°œë…

ì–‘ë°©í–¥ BFSëŠ” ì‹œì‘ì ê³¼ ëª©í‘œì ì—ì„œ **ë™ì‹œì— íƒìƒ‰**ì„ ì‹œì‘í•˜ì—¬, ë‘ íƒìƒ‰ì´ ë§Œë‚˜ëŠ” ì§€ì ì„ ì°¾ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

### ğŸ“Š ì‹œê°„ ë³µì¡ë„ ê°œì„ 

- **ì¼ë°˜ BFS**: O(b\^d)
- **ì–‘ë°©í–¥ BFS**: O(b\^(d/2))
ì—¬ê¸°ì„œ bëŠ” ë¶„ê¸° ê³„ìˆ˜(branching factor), dëŠ” ê¹Šì´ì…ë‹ˆë‹¤.

### ğŸ’» Python êµ¬í˜„

```
from collections import deque
from typing import Dict, List, Optional, Set

def bidirectional_bfs(graph: Dict[int, List[int]], 
                       start: int, 
                       goal: int) -> Optional[List[int]]:
    """
    ì–‘ë°©í–¥ BFS êµ¬í˜„
    """
    if start == goal:
        return [start]
    
    # ì „ë°© íƒìƒ‰ (ì‹œì‘ì ì—ì„œ)
    forward_queue = deque([start])
    forward_visited = {start: None}
    
    # í›„ë°© íƒìƒ‰ (ëª©í‘œì ì—ì„œ)
    backward_queue = deque([goal])
    backward_visited = {goal: None}
    
    while forward_queue and backward_queue:
        # ì „ë°© íƒìƒ‰ 1ë‹¨ê³„
        meeting_point = bfs_step(graph, forward_queue, forward_visited, backward_visited)
        if meeting_point is not None:
            return construct_bidirectional_path(forward_visited, backward_visited, start, goal, meeting_point)
        
        # í›„ë°© íƒìƒ‰ 1ë‹¨ê³„
        meeting_point = bfs_step(graph, backward_queue, backward_visited, forward_visited)
        if meeting_point is not None:
            return construct_bidirectional_path(forward_visited, backward_visited, start, goal, meeting_point)
    
    return None  # ê²½ë¡œ ì—†ìŒ

def bfs_step(graph: Dict[int, List[int]], 
             queue: deque, 
             visited: Dict[int, Optional[int]], 
             other_visited: Dict[int, Optional[int]]) -> Optional[int]:
    """
    BFS í•œ ë‹¨ê³„ ì‹¤í–‰
    """
    if not queue:
        return None
    
    node = queue.popleft()
    
    for neighbor in graph.get(node, []):
        # ë‹¤ë¥¸ ìª½ íƒìƒ‰ê³¼ ë§Œë‚¨
        if neighbor in other_visited:
            return neighbor
        
        # ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ
        if neighbor not in visited:
            visited[neighbor] = node
            queue.append(neighbor)
    
    return None

def construct_bidirectional_path(forward_visited: Dict[int, Optional[int]], 
                                  backward_visited: Dict[int, Optional[int]], 
                                  start: int, 
                                  goal: int, 
                                  meeting_point: int) -> List[int]:
    """
    ì–‘ë°©í–¥ íƒìƒ‰ ê²°ê³¼ë¡œ ê²½ë¡œ êµ¬ì„±
    """
    # ì „ë°© ê²½ë¡œ (ì‹œì‘ -> ë§Œë‚¨ì )
    forward_path = []
    node = meeting_point
    while node is not None:
        forward_path.append(node)
        node = forward_visited[node]
    forward_path.reverse()
    
    # í›„ë°© ê²½ë¡œ (ë§Œë‚¨ì  -> ëª©í‘œ)
    backward_path = []
    node = backward_visited[meeting_point]
    while node is not None:
        backward_path.append(node)
        node = backward_visited[node]
    
    # ê²½ë¡œ í•©ì¹˜ê¸°
    return forward_path + backward_path

# ì‚¬ìš© ì˜ˆì œ
graph = {
    1: [2, 3],
    2: [1, 4, 5],
    3: [1, 6, 7],
    4: [2, 8],
    5: [2, 8],
    6: [3, 9],
    7: [3, 9],
    8: [4, 5, 10],
    9: [6, 7, 10],
    10: [8, 9]
}

path = bidirectional_bfs(graph, 1, 10)
print(f"ì–‘ë°©í–¥ BFS ê²½ë¡œ: {' -> '.join(map(str, path))}")
# ì¶œë ¥: ì–‘ë°©í–¥ BFS ê²½ë¡œ: 1 -> 2 -> 4 -> 8 -> 10
```

### ğŸ“Š ì„±ëŠ¥ ë¹„êµ

```
import time
from collections import deque, defaultdict
import random

def compare_bfs_performance(num_nodes: int):
    # ëœë¤ ê·¸ë˜í”„ ìƒì„±
    graph = defaultdict(list)
    for i in range(num_nodes):
        for _ in range(random.randint(1, 5)):
            neighbor = random.randint(0, num_nodes - 1)
            if neighbor != i:
                graph[i].append(neighbor)
    
    start, goal = 0, num_nodes - 1
    
    # ì¼ë°˜ BFS
    start_time = time.time()
    bfs_shortest_path(graph, start, goal)
    bfs_time = (time.time() - start_time) * 1000
    
    # ì–‘ë°©í–¥ BFS
    start_time = time.time()
    bidirectional_bfs(graph, start, goal)
    bi_bfs_time = (time.time() - start_time) * 1000
    
    print(f"ë…¸ë“œ ìˆ˜: {num_nodes}")
    print(f"  ì¼ë°˜ BFS: {bfs_time:.3f}ms")
    print(f"  ì–‘ë°©í–¥ BFS: {bi_bfs_time:.3f}ms")
    print(f"  ì„±ëŠ¥ í–¥ìƒ: {(bfs_time / bi_bfs_time):.2f}x\n")

for nodes in [100, 500, 1000, 5000]:
    compare_bfs_performance(nodes)
```

## ğŸ’° 0-1 BFS

### ğŸ“ ê°œë…

**0-1 BFS**ëŠ” ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 0 ë˜ëŠ” 1ë§Œ ìˆëŠ” ê·¸ë˜í”„ì—ì„œ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ìµœì í™” ê¸°ë²•ì…ë‹ˆë‹¤.

### ğŸ’¡ í•µì‹¬ ì•„ì´ë””ì–´

- ê°€ì¤‘ì¹˜ 0ì¸ ê°„ì„ : **ë±(deque)ì˜ ì•ì— ì‚½ì…**
- ê°€ì¤‘ì¹˜ 1ì¸ ê°„ì„ : **ë±ì˜ ë’¤ì— ì‚½ì…**

### ğŸ’» Python êµ¬í˜„

```
from collections import deque
from typing import Dict, List, Tuple
import math

def zero_one_bfs(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:
    """
    0-1 BFS êµ¬í˜„
    graph: {node: [(neighbor, weight), ...]}
    weightëŠ” 0 ë˜ëŠ” 1ë§Œ ê°€ëŠ¥
    
    Returns:
        ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬
    """
    distances = {node: math.inf for node in graph}
    distances[start] = 0
    
    dq = deque([start])
    
    while dq:
        node = dq.popleft()
        
        for neighbor, weight in graph.get(node, []):
            new_dist = distances[node] + weight
            
            if new_dist < distances[neighbor]:
                distances[neighbor] = new_dist
                
                if weight == 0:
                    # ê°€ì¤‘ì¹˜ 0: ì•ì— ì‚½ì…
                    dq.appendleft(neighbor)
                else:
                    # ê°€ì¤‘ì¹˜ 1: ë’¤ì— ì‚½ì…
                    dq.append(neighbor)
    
    return distances

# ì‚¬ìš© ì˜ˆì œ
graph = {
    1: [(2, 0), (3, 1)],      # 1->2 ê°€ì¤‘ì¹˜ 0, 1->3 ê°€ì¤‘ì¹˜ 1
    2: [(4, 1), (5, 0)],      # 2->4 ê°€ì¤‘ì¹˜ 1, 2->5 ê°€ì¤‘ì¹˜ 0
    3: [(6, 0)],              # 3->6 ê°€ì¤‘ì¹˜ 0
    4: [(7, 0)],
    5: [(7, 1)],
    6: [(7, 1)],
    7: []
}

distances = zero_one_bfs(graph, 1)
for node, dist in sorted(distances.items()):
    if dist != math.inf:
        print(f"ë…¸ë“œ {node}ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬: {dist}")

# ì¶œë ¥:
# ë…¸ë“œ 1ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬: 0
# ë…¸ë“œ 2ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬: 0
# ë…¸ë“œ 3ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬: 1
# ë…¸ë“œ 4ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬: 1
# ë…¸ë“œ 5ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬: 0
# ë…¸ë“œ 6ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬: 1
# ë…¸ë“œ 7ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬: 1
```

### ğŸ® ì‹¤ì „ ì˜ˆì œ: ë¯¸ë¡œì—ì„œ ë¬¸ ì—´ê¸°

```
from collections import deque
from typing import List, Tuple

def maze_with_keys(maze: List[List[str]]) -> int:
    """
    ë¯¸ë¡œ ë¬¸ì œ: 0-1 BFS í™œìš©
    '.': í†µë¡œ (0 ë¹„ìš©)
    'D': ë¬¸ (ì—´ë ¤ë©´ 0 ë¹„ìš©, ë‹«í˜€ìˆìœ¼ë©´ 1 ë¹„ìš©)
    '#': ë²½ (ì´ë™ ë¶ˆê°€)
    'S': ì‹œì‘ì 
    'E': ë„ì°©ì 
    """
    rows, cols = len(maze), len(maze[0])
    
    # ì‹œì‘ì ê³¼ ë„ì°©ì  ì°¾ê¸°
    start, end = None, None
    for i in range(rows):
        for j in range(cols):
            if maze[i][j] == 'S':
                start = (i, j)
            elif maze[i][j] == 'E':
                end = (i, j)
    
    # 0-1 BFS
    dq = deque([(start[0], start[1], 0)])  # (row, col, keys_used)
    visited = {start: 0}
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    while dq:
        row, col, keys = dq.popleft()
        
        if (row, col) == end:
            return keys
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            new_pos = (new_row, new_col)
            
            if 0 <= new_row < rows and 0 <= new_col < cols:
                cell = maze[new_row][new_col]
                
                if cell == '#':
                    continue
                
                # ë¬¸ì„ ì—´ ë•Œ í‚¤ ì‚¬ìš©
                new_keys = keys + (1 if cell == 'D' else 0)
                
                # ë” ì ì€ í‚¤ë¡œ ë°©ë¬¸ ê°€ëŠ¥í•œ ê²½ìš°ë§Œ
                if new_pos not in visited or visited[new_pos] > new_keys:
                    visited[new_pos] = new_keys
                    
                    if cell == 'D':
                        dq.append((new_row, new_col, new_keys))  # ë’¤ì— ì¶”ê°€
                    else:
                        dq.appendleft((new_row, new_col, new_keys))  # ì•ì— ì¶”ê°€
    
    return -1

# ì‚¬ìš© ì˜ˆì œ
maze = [
    ['S', '.', '.', 'D', '.'],
    ['.', '#', '.', '#', '.'],
    ['.', '.', 'D', '.', '.'],
    ['#', '.', '#', '#', '.'],
    ['.', '.', '.', '.', 'E']
]

result = maze_with_keys(maze)
print(f"ìµœì†Œ ë¬¸ ì—´ê¸° íšŸìˆ˜: {result}")
# ì¶œë ¥: ìµœì†Œ ë¬¸ ì—´ê¸° íšŸìˆ˜: 2
```

## ğŸŒ Multi-Source BFS

### ğŸ“ ê°œë…

ì—¬ëŸ¬ ì‹œì‘ì ì—ì„œ **ë™ì‹œì— BFS**ë¥¼ ì‹œì‘í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

### ğŸ’» Python êµ¬í˜„

```
from collections import deque
from typing import List, Set, Tuple

def multi_source_bfs(grid: List[List[int]], sources: List[Tuple[int, int]]) -> List[List[int]]:
    """
    ë‹¤ì¤‘ ì‹œì‘ì  BFS
    
    Args:
        grid: 2D ê·¸ë¦¬ë“œ
        sources: ì‹œì‘ì  ë¦¬ìŠ¤íŠ¸
    
    Returns:
        ê° ì…€ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì‹œì‘ì ê¹Œì§€ì˜ ê±°ë¦¬
    """
    rows, cols = len(grid), len(grid[0])
    distances = [[-1] * cols for _ in range(rows)]
    
    # ëª¨ë“  ì‹œì‘ì ì„ íì— ì¶”ê°€
    queue = deque()
    for row, col in sources:
        queue.append((row, col, 0))
        distances[row][col] = 0
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    while queue:
        row, col, dist = queue.popleft()
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                distances[new_row][new_col] == -1 and 
                grid[new_row][new_col] == 0):
                
                distances[new_row][new_col] = dist + 1
                queue.append((new_row, new_col, dist + 1))
    
    return distances

# ì‚¬ìš© ì˜ˆì œ: ë³‘ì›ê¹Œì§€ì˜ ê±°ë¦¬
grid = [
    [0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0]
]

# ë³‘ì› ìœ„ì¹˜
hospitals = [(0, 0), (0, 4), (4, 0), (4, 4)]

distances = multi_source_bfs(grid, hospitals)

print("ê° ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë³‘ì›ê¹Œì§€ì˜ ê±°ë¦¬:")
for row in distances:
    print(' '.join(f'{d:2d}' if d != -1 else ' #' for d in row))

# ì¶œë ¥:
# ê° ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë³‘ì›ê¹Œì§€ì˜ ê±°ë¦¬:
#  0  1  2  1  0
#  1  #  2  #  1
#  2  2  2  2  2
#  1  #  2  #  1
#  0  1  2  1  0
```

### ğŸ¥ ì‹¤ì „ ì˜ˆì œ: ì—­ ë°°ì¹˜ ìµœì í™”

```
def optimize_station_placement(city_grid: List[List[int]], 
                                num_stations: int) -> List[Tuple[int, int]]:
    """
    ë„ì‹œì— ì—­ì„ ë°°ì¹˜í•˜ì—¬ ìµœëŒ€ ê±°ë¦¬ë¥¼ ìµœì†Œí™”
    """
    rows, cols = len(city_grid), len(city_grid[0])
    
    # ê°€ëŠ¥í•œ ëª¨ë“  ìœ„ì¹˜
    possible_positions = []
    for i in range(rows):
        for j in range(cols):
            if city_grid[i][j] == 0:  # ë¹ˆ ê³µê°„
                possible_positions.append((i, j))
    
    # ê°€ì¥ ë¨¼ ê±°ë¦¬ë¥¼ ìµœì†Œí™”í•˜ëŠ” ì—­ ë°°ì¹˜ ì°¾ê¸°
    # (ì‹¤ì œë¡œëŠ” í›ˆë¦¬ìŠ¤í‹± íƒìƒ‰ ë“±ì„ ì‚¬ìš©)
    best_stations = []
    min_max_distance = float('inf')
    
    # ì˜ˆì‹œ: ê· ë“±í•˜ê²Œ ë¶„í¬ëœ ìœ„ì¹˜ ì„ íƒ
    step = len(possible_positions) // num_stations
    best_stations = [possible_positions[i * step] for i in range(num_stations)]
    
    # Multi-source BFSë¡œ ê±°ë¦¬ ê³„ì‚°
    distances = multi_source_bfs(city_grid, best_stations)
    
    return best_stations, distances

# ì‚¬ìš© ì˜ˆì œ
city = [
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0]
]

stations, distances = optimize_station_placement(city, 4)
print(f"ì¶”ì²œ ì—­ ìœ„ì¹˜: {stations}")
```

---

# ğŸ§© ì‹¤ì „ ì½”ë”© í…ŒìŠ¤íŠ¸ ë¬¸ì œ

ì´ì œ ì‹¤ì œ ì½”ë”© í…ŒìŠ¤íŠ¸ì—ì„œ ìì£¼ ë‚˜ì˜¤ëŠ” BFS ë¬¸ì œë“¤ì„ í’€ì–´ë³´ê² ìŠµë‹ˆë‹¤.

## ğŸ¥‡ ë¬¸ì œ 1: ì„¬ì˜ ê°œìˆ˜ (Number of Islands)

### ğŸ“ ë¬¸ì œ ì„¤ëª…

2D ê·¸ë¦¬ë“œê°€ ì£¼ì–´ì§€ê³ , '1'ì€ ë•…, '0'ì€ ë¬¼ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì„¬ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.

### ğŸ’¡ í’€ì´ ì „ëµ

1. ê° 'ë•…' ì…€ì—ì„œ BFS ì‹œì‘
2. ì—°ê²°ëœ ëª¨ë“  'ë•…'ì„ ë°©ë¬¸ ì²˜ë¦¬
3. BFS ì‹¤í–‰ íšŸìˆ˜ = ì„¬ì˜ ê°œìˆ˜

### ğŸ’» ì½”ë“œ

```
from collections import deque
from typing import List

def numIslands(grid: List[List[str]]) -> int:
    """
    LeetCode 200: Number of Islands
    ë‚œì´ë„: Medium
    """
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    visited = set()
    islands = 0
    
    def bfs(start_row: int, start_col: int):
        queue = deque([(start_row, start_col)])
        visited.add((start_row, start_col))
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while queue:
            row, col = queue.popleft()
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if (0 <= new_row < rows and 
                    0 <= new_col < cols and 
                    grid[new_row][new_col] == '1' and 
                    (new_row, new_col) not in visited):
                    
                    visited.add((new_row, new_col))
                    queue.append((new_row, new_col))
    
    # ëª¨ë“  ì…€ íƒìƒ‰
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1' and (i, j) not in visited:
                bfs(i, j)
                islands += 1
    
    return islands

# í…ŒìŠ¤íŠ¸
grid1 = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
]
print(f"ì„¬ì˜ ê°œìˆ˜: {numIslands(grid1)}")  # ì¶œë ¥: 1

grid2 = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
]
print(f"ì„¬ì˜ ê°œìˆ˜: {numIslands(grid2)}")  # ì¶œë ¥: 3
```

## ğŸ¥ˆ ë¬¸ì œ 2: ì˜¤ë Œì§€ ì½ê¸° (Rotting Oranges)

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ê·¸ë¦¬ë“œì—ì„œ:
- 0: ë¹ˆ ì…€
- 1: ì‹ ì„ í•œ ì˜¤ë Œì§€
- 2: ì¸ì€ ì˜¤ë Œì§€
ë§¤ë¶„ ì¸ì€ ì˜¤ë Œì§€ì˜ 4ë°©í–¥ ì¸ì ‘ ì…€ì˜ ì‹ ì„ í•œ ì˜¤ë Œì§€ê°€ ì½ìŠµë‹ˆë‹¤. ëª¨ë“  ì˜¤ë Œì§€ê°€ ì½ëŠ” ë° ê±¸ë¦¬ëŠ” ìµœì†Œ ì‹œê°„ì„ ë°˜í™˜í•˜ì„¸ìš”.

### ğŸ’¡ í’€ì´ ì „ëµ

1. ëª¨ë“  ì¸ì€ ì˜¤ë Œì§€ë¥¼ íì— ì¶”ê°€ (Multi-source BFS)
2. BFSë¡œ ë ˆë²¨ë³„ë¡œ íƒìƒ‰
3. ê° ë ˆë²¨ = 1ë¶„

### ğŸ’» ì½”ë“œ

```
from collections import deque
from typing import List

def orangesRotting(grid: List[List[int]]) -> int:
    """
    LeetCode 994: Rotting Oranges
    ë‚œì´ë„: Medium
    """
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    # ì´ˆê¸° ìƒíƒœ íŒŒì•…
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 2:
                queue.append((i, j, 0))  # (row, col, time)
            elif grid[i][j] == 1:
                fresh_count += 1
    
    # ì‹ ì„ í•œ ì˜¤ë Œì§€ê°€ ì—†ìœ¼ë©´ 0 ë°˜í™˜
    if fresh_count == 0:
        return 0
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    max_time = 0
    
    # Multi-source BFS
    while queue:
        row, col, time = queue.popleft()
        max_time = max(max_time, time)
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                grid[new_row][new_col] == 1):
                
                # ì‹ ì„ í•œ ì˜¤ë Œì§€ë¥¼ ì¸ì€ ì˜¤ë Œì§€ë¡œ ë³€ê²½
                grid[new_row][new_col] = 2
                fresh_count -= 1
                queue.append((new_row, new_col, time + 1))
    
    # ë‚¨ì€ ì‹ ì„ í•œ ì˜¤ë Œì§€ê°€ ìˆìœ¼ë©´ -1
    return max_time if fresh_count == 0 else -1

# í…ŒìŠ¤íŠ¸
grid1 = [
    [2,1,1],
    [1,1,0],
    [0,1,1]
]
print(f"ìµœì†Œ ì‹œê°„: {orangesRotting(grid1)}ë¶„")  # ì¶œë ¥: 4

grid2 = [
    [2,1,1],
    [0,1,1],
    [1,0,1]
]
print(f"ìµœì†Œ ì‹œê°„: {orangesRotting(grid2)}ë¶„")  # ì¶œë ¥: -1

grid3 = [[0,2]]
print(f"ìµœì†Œ ì‹œê°„: {orangesRotting(grid3)}ë¶„")  # ì¶œë ¥: 0
```

## ğŸ¥‰ ë¬¸ì œ 3: ì´ì§„ í–‰ë ¬ì˜ ìµœë‹¨ ê²½ë¡œ (Shortest Path in Binary Matrix)

### ğŸ“ ë¬¸ì œ ì„¤ëª…

N x N ì´ì§„ í–‰ë ¬ì—ì„œ (0,0)ë¶€í„° (N-1,N-1)ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ìœ¼ì„¸ìš”. 0ì€ ë¹„ì–´ìˆëŠ” ì…€ì´ê³  1ì€ ì¥ì• ë¬¼ì…ë‹ˆë‹¤. **8ë°©í–¥ ì´ë™** ê°€ëŠ¥í•©ë‹ˆë‹¤.

### ğŸ’¡ í’€ì´ ì „ëµ

1. BFSë¡œ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°
2. 8ë°©í–¥ ì´ë™ (ëŒ€ê°ì„  í¬í•¨)
3. ì‹œì‘ì ê³¼ ë„ì°©ì ì´ 0ì¸ì§€ í™•ì¸

### ğŸ’» ì½”ë“œ

```
from collections import deque
from typing import List

def shortestPathBinaryMatrix(grid: List[List[int]]) -> int:
    """
    LeetCode 1091: Shortest Path in Binary Matrix
    ë‚œì´ë„: Medium
    """
    n = len(grid)
    
    # ì‹œì‘ì ì´ë‚˜ ë„ì°©ì ì´ ë§‰íŒ ê²½ìš°
    if grid[0][0] == 1 or grid[n-1][n-1] == 1:
        return -1
    
    # í•œ ì¹¸ì§œë¦¬ ê·¸ë¦¬ë“œ
    if n == 1:
        return 1
    
    # 8ë°©í–¥ ì´ë™
    directions = [
        (0, 1), (1, 0), (0, -1), (-1, 0),  # 4ë°©í–¥
        (1, 1), (1, -1), (-1, 1), (-1, -1)  # ëŒ€ê°ì„ 
    ]
    
    queue = deque([(0, 0, 1)])  # (row, col, path_length)
    visited = {(0, 0)}
    
    while queue:
        row, col, length = queue.popleft()
        
        # ë„ì°©ì  ë„ë‹¬
        if row == n - 1 and col == n - 1:
            return length
        
        # 8ë°©í–¥ íƒìƒ‰
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < n and 
                0 <= new_col < n and 
                grid[new_row][new_col] == 0 and 
                (new_row, new_col) not in visited):
                
                visited.add((new_row, new_col))
                queue.append((new_row, new_col, length + 1))
    
    return -1  # ê²½ë¡œ ì—†ìŒ

# í…ŒìŠ¤íŠ¸
grid1 = [
    [0,1],
    [1,0]
]
print(f"ìµœë‹¨ ê²½ë¡œ ê¸¸ì´: {shortestPathBinaryMatrix(grid1)}")  # ì¶œë ¥: 2

grid2 = [
    [0,0,0],
    [1,1,0],
    [1,1,0]
]
print(f"ìµœë‹¨ ê²½ë¡œ ê¸¸ì´: {shortestPathBinaryMatrix(grid2)}")  # ì¶œë ¥: 4

grid3 = [
    [1,0,0],
    [1,1,0],
    [1,1,0]
]
print(f"ìµœë‹¨ ê²½ë¡œ ê¸¸ì´: {shortestPathBinaryMatrix(grid3)}")  # ì¶œë ¥: -1


## ğŸ† ë¬¸ì œ 4: ë‹¨ì–´ ì‚¬ë‹¤ë¦¬ (Word Ladder)

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ì‹œì‘ ë‹¨ì–´ì—ì„œ í•œ ë²ˆì— í•œ ê¸€ìì”© ë°”ê¿” ëª©í‘œ ë‹¨ì–´ë¡œ ë³€í™˜í•˜ëŠ” ìµœë‹¨ ìˆ˜ì—´ ê¸¸ì´ë¥¼ êµ¬í•˜ì„¸ìš”. ë‹¨ì–´ ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ë‹¨ì–´ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.

### ğŸ’¡ í’€ì´ ì „ëµ

1. ê° ë‹¨ì–´ë¥¼ ê·¸ë˜í”„ì˜ ë…¸ë“œë¡œ ì·¨ê¸‰
2. í•œ ê¸€ìë§Œ ë‹¤ë¥¸ ë‹¨ì–´ = ê°„ì„ 
3. BFSë¡œ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°

### ğŸ’» ì½”ë“œ

```

from collections import deque
from typing import List
def ladderLength(beginWord: str, endWord: str, wordList: List\[str\]) -\> int:
	"""
	LeetCode 127: Word Ladder
	ë‚œì´ë„: Hard
	"""
	word_set = set(wordList)
	if endWord not in word_set:
		return 0
	queue = deque(\[(beginWord, 1)\])  # (word, length)
	visited = \{beginWord\}
	while queue:
		word, length = queue.popleft()

		# ëª©í‘œ ë‹¨ì–´ ë„ë‹¬

		if word == endWord:
			return length

		# í•œ ê¸€ìì”© ë°”ê¿”ë³´ê¸°

		for i in range(len(word)):
			for c in 'abcdefghijklmnopqrstuvwxyz':
				next_word = word\[:i\] + c + word\[i+1:\]
				if next_word in word_set and next_word not in visited:
					visited.add(next_word)
					queue.append((next_word, length + 1))
	return 0  # ë³€í™˜ ë¶ˆê°€

# í…ŒìŠ¤íŠ¸

beginWord = "hit"
endWord = "cog"
wordList = \["hot","dot","dog","lot","log","cog"\]
result = ladderLength(beginWord, endWord, wordList)
print(f"ìµœë‹¨ ë³€í™˜ ìˆ˜ì—´ ê¸¸ì´: \{result\}")

# ì¶œë ¥: 5

# ì„¤ëª…: hit -\> hot -\> dot -\> dog -\> cog

wordList2 = \["hot","dot","dog","lot","log"\]
result2 = ladderLength(beginWord, endWord, wordList2)
print(f"ìµœë‹¨ ë³€í™˜ ìˆ˜ì—´ ê¸¸ì´: \{result2\}")

# ì¶œë ¥: 0 (cogê°€ wordListì— ì—†ìŒ)

```

## ğŸ… ë¬¸ì œ 5: ë°±ì¤€ 2178 - ë¯¸ë¡œ íƒìƒ‰

### ğŸ“ ë¬¸ì œ ì„¤ëª…

NÃ—Mí¬ê¸°ì˜ ë°°ì—´ë¡œ í‘œí˜„ë˜ëŠ” ë¯¸ë¡œê°€ ìˆë‹¤. 1ì€ ì´ë™í•  ìˆ˜ ìˆëŠ” ì¹¸ì„ ë‚˜íƒ€ë‚´ê³ , 0ì€ ì´ë™í•  ìˆ˜ ì—†ëŠ” ì¹¸ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. (1, 1)ì—ì„œ ì¶œë°œí•˜ì—¬ (N, M)ì˜ ìœ„ì¹˜ë¡œ ì´ë™í•  ë•Œ ì§€ë‚˜ì•¼ í•˜ëŠ” ìµœì†Œì˜ ì¹¸ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

### ğŸ’¡ í’€ì´ ì „ëµ

1. BFSë¡œ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°
2. ì‹œì‘ ì¹¸ë„ í¬í•¨í•˜ì—¬ ì¹´ìš´íŠ¸
3. ìƒí•˜ì¢Œìš° 4ë°©í–¥ ì´ë™

### ğŸ’» ì½”ë“œ

```

from collections import deque
from typing import List
def solve_baekjoon_2178():
	"""
	ë°±ì¤€ 2178: ë¯¸ë¡œ íƒìƒ‰
	ë‚œì´ë„: Silver 1
	"""

	# ì…ë ¥ ë°›ê¸°

	n, m = map(int, input().split())
	maze = \[\]
	for _ in range(n):
		row = input().strip()
		maze.append(\[int(c) for c in row\])

	# BFS

	queue = deque(\[(0, 0, 1)\])  # (row, col, distance)
	visited = \[\[False\] \* m for _ in range(n)\]
	visited\[0\]\[0\] = True
	directions = \[(0, 1), (1, 0), (0, -1), (-1, 0)\]
	while queue:
		row, col, dist = queue.popleft()

		# ë„ì°©ì  ë„ë‹¬

		if row == n - 1 and col == m - 1:
			return dist

		# 4ë°©í–¥ íƒìƒ‰

		for dr, dc in directions:
			new_row, new_col = row + dr, col + dc
			if (0 \<= new_row \< n and 
				0 \<= new_col \< m and 
				maze\[new_row\]\[new_col\] == 1 and 
				not visited\[new_row\]\[new_col\]):
				visited\[new_row\]\[new_col\] = True
				queue.append((new_row, new_col, dist + 1))
	return -1

# í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ (ì‹¤ì œ ì œì¶œì‹œì—ëŠ” ì‚¬ìš© ì•ˆ í•¨)

def test_maze():

	# ì˜ˆì œ ì…ë ¥

	# 4 6

	# 101111

	# 101010

	# 101011

	# 111011

	maze = \[
		\[1,0,1,1,1,1\],
		\[1,0,1,0,1,0\],
		\[1,0,1,0,1,1\],
		\[1,1,1,0,1,1\]
	\]
	n, m = 4, 6
	queue = deque(\[(0, 0, 1)\])
	visited = \[\[False\] \* m for _ in range(n)\]
	visited\[0\]\[0\] = True
	directions = \[(0, 1), (1, 0), (0, -1), (-1, 0)\]
	while queue:
		row, col, dist = queue.popleft()
		if row == n - 1 and col == m - 1:
			print(f"ìµœë‹¨ ê²½ë¡œ: \{dist\}")
			return dist
		for dr, dc in directions:
			new_row, new_col = row + dr, col + dc
			if (0 \<= new_row \< n and 
				0 \<= new_col \< m and 
				maze\[new_row\]\[new_col\] == 1 and 
				not visited\[new_row\]\[new_col\]):
				visited\[new_row\]\[new_col\] = True
				queue.append((new_row, new_col, dist + 1))
test_maze()  # ì¶œë ¥: 15

```

## ğŸ’ª ë¬¸ì œ 6: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - íƒ€ê²Ÿ ë„˜ë²„

### ğŸ“ ë¬¸ì œ ì„¤ëª…

nê°œì˜ ìŒì´ ì•„ë‹Œ ì •ìˆ˜ë“¤ì´ ìˆìŠµë‹ˆë‹¤. ì´ ìˆ˜ë¥¼ ì ì ˆíˆ ë”í•˜ê±°ë‚˜ ë¹¼ì„œ íƒ€ê²Ÿ ë„˜ë²„ë¥¼ ë§Œë“¤ë ¤ê³  í•©ë‹ˆë‹¤. íƒ€ê²Ÿ ë„˜ë²„ë¥¼ ë§Œë“œëŠ” ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ë¼.

### ğŸ’¡ í’€ì´ ì „ëµ

1. DFSë‚˜ BFS ëª¨ë‘ ê°€ëŠ¥í•˜ì§€ë§Œ BFSë¡œ í’€ ìˆ˜ ìˆìŒ
2. ê° ìˆ«ìë¥¼ ë”í•˜ê±°ë‚˜ ë¹¼ëŠ” 2ê°€ì§€ ì„ íƒ
3. ëª¨ë“  ìˆ«ìë¥¼ ì‚¬ìš©í•œ í›„ íƒ€ê²Ÿê³¼ ê°™ì€ì§€ í™•ì¸

### ğŸ’» ì½”ë“œ

```

from collections import deque
from typing import List
def solution(numbers: List\[int\], target: int) -\> int:
	"""
	í”„ë¡œê·¸ë˜ë¨¸ìŠ¤: íƒ€ê²Ÿ ë„˜ë²„
	Level 2
	"""
	queue = deque(\[(0, 0)\])  # (index, current_sum)
	count = 0
	while queue:
		index, current_sum = queue.popleft()

		# ëª¨ë“  ìˆ«ìë¥¼ ì‚¬ìš©í•œ ê²½ìš°

		if index == len(numbers):
			if current_sum == target:
				count += 1
		else:

			# ë”í•˜ê¸°

			queue.append((index + 1, current_sum + numbers\[index\]))

			# ë¹¼ê¸°

			queue.append((index + 1, current_sum - numbers\[index\]))
	return count

# í…ŒìŠ¤íŠ¸

numbers = \[1, 1, 1, 1, 1\]
target = 3
print(f"íƒ€ê²Ÿ ë„˜ë²„ë¥¼ ë§Œë“œëŠ” ë°©ë²•: \{solution(numbers, target)\}ê°œ")

# ì¶œë ¥: 5

# ì„¤ëª…: -1+1+1+1+1 = 3

# +1-1+1+1+1 = 3

# +1+1-1+1+1 = 3

# +1+1+1-1+1 = 3

# +1+1+1+1-1 = 3

numbers2 = \[4, 1, 2, 1\]
target2 = 4
print(f"íƒ€ê²Ÿ ë„˜ë²„ë¥¼ ë§Œë“œëŠ” ë°©ë²•: \{solution(numbers2, target2)\}ê°œ")

# ì¶œë ¥: 2

# ì„¤ëª…: +4+1-2+1 = 4

# +4-1+2-1 = 4

```

## ğŸ¥‡ ë¬¸ì œ 7: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - ë„¤íŠ¸ì›Œí¬

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ë„¤íŠ¸ì›Œí¬ë€ ì»´í“¨í„° ìƒí˜¸ ê°„ì— ì •ë³´ë¥¼ êµí™˜í•  ìˆ˜ ìˆë„ë¡ ì—°ê²°ëœ í˜•íƒœë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ì»´í“¨í„°ì˜ ê°œìˆ˜ n, ì—°ê²°ì— ëŒ€í•œ ì •ë³´ê°€ ë‹´ê¸´ 2ì°¨ì› ë°°ì—´ computersê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë„¤íŠ¸ì›Œí¬ì˜ ê°œìˆ˜ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.

### ğŸ’¡ í’€ì´ ì „ëµ

1. ê° ì»´í“¨í„°ì—ì„œ BFS ì‹¤í–‰
2. ì—°ê²°ëœ ëª¨ë“  ì»´í“¨í„°ë¥¼ ë°©ë¬¸ ì²˜ë¦¬
3. BFS ì‹¤í–‰ íšŸìˆ˜ = ë„¤íŠ¸ì›Œí¬ ê°œìˆ˜

### ğŸ’» ì½”ë“œ

```

from collections import deque
from typing import List
def solution(n: int, computers: List\[List\[int\]\]) -\> int:
	"""
	í”„ë¡œê·¸ë˜ë¨¸ìŠ¤: ë„¤íŠ¸ì›Œí¬
	Level 3
	"""
	def bfs(start: int):
		queue = deque(\[start\])
		visited\[start\] = True
		while queue:
			node = queue.popleft()
			for neighbor in range(n):

				# ì—°ê²°ë˜ì–´ ìˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìœ¼ë©´

				if computers\[node\]\[neighbor\] == 1 and not visited\[neighbor\]:
					visited\[neighbor\] = True
					queue.append(neighbor)
	visited = \[False\] \* n
	networks = 0
	for i in range(n):
		if not visited\[i\]:
			bfs(i)
			networks += 1
	return networks

# í…ŒìŠ¤íŠ¸

computers1 = \[
	\[1, 1, 0\],
	\[1, 1, 0\],
	\[0, 0, 1\]
\]
print(f"ë„¤íŠ¸ì›Œí¬ ê°œìˆ˜: \{solution(3, computers1)\}")

# ì¶œë ¥: 2

computers2 = \[
	\[1, 1, 0\],
	\[1, 1, 1\],
	\[0, 1, 1\]
\]
print(f"ë„¤íŠ¸ì›Œí¬ ê°œìˆ˜: \{solution(3, computers2)\}")

# ì¶œë ¥: 1

```

## ğŸ‰ ë¬¸ì œ 8: ë°±ì¤€ 7576 - í† ë§ˆí† 

### ğŸ“ ë¬¸ì œ ì„¤ëª…

í† ë§ˆí† ê°€ ë³´ê´€ë˜ëŠ” ì°½ê³ ì— ë³´ê´€ë˜ëŠ” í† ë§ˆí† ë“¤ ì¤‘ì—ëŠ” ìì€ ê²ƒë„ ìˆì§€ë§Œ, ì•„ì§ ìì§€ ì•Šì€ í† ë§ˆí† ë“¤ë„ ìˆì„ ìˆ˜ ìˆë‹¤. ë³´ê´€ í›„ í•˜ë£¨ê°€ ì§€ë‚˜ë©´, ìì€ í† ë§ˆí† ë“¤ì˜ ì¸ì ‘í•œ ê³³ì— ìˆëŠ” ìì§€ ì•Šì€ í† ë§ˆí† ë“¤ì€ ìì€ í† ë§ˆí† ì˜ ì˜í–¥ì„ ë°›ì•„ ìê²Œ ëœë‹¤. í† ë§ˆí† ê°€ ëª¨ë‘ ìì„ ë•Œê¹Œì§€ì˜ ìµœì†Œ ë‚ ì§œë¥¼ êµ¬í•˜ë¼.

### ğŸ’¡ í’€ì´ ì „ëµ

1. ëª¨ë“  ìì€ í† ë§ˆí† ë¥¼ íì— ì¶”ê°€ (Multi-source BFS)
2. ë ˆë²¨ë³„ë¡œ BFS ì‹¤í–‰
3. ê° ë ˆë²¨ = 1ì¼

### ğŸ’» ì½”ë“œ

```

from collections import deque
from typing import List
def solve_tomato():
	"""
	ë°±ì¤€ 7576: í† ë§ˆí† 
	ë‚œì´ë„: Gold 5
	"""

	# ì…ë ¥

	m, n = map(int, input().split())
	grid = \[\]
	for _ in range(n):
		grid.append(list(map(int, input().split())))

	# ì´ˆê¸° ì„¤ì •

	queue = deque()
	unripe_count = 0
	for i in range(n):
		for j in range(m):
			if grid\[i\]\[j\] == 1:  # ìì€ í† ë§ˆí† 
				queue.append((i, j, 0))  # (row, col, day)
			elif grid\[i\]\[j\] == 0:  # ì•ˆ ìì€ í† ë§ˆí† 
				unripe_count += 1

	# ëª¨ë‘ ìì€ ìƒíƒœ

	if unripe_count == 0:
		return 0
	directions = \[(0, 1), (1, 0), (0, -1), (-1, 0)\]
	max_day = 0

	# Multi-source BFS

	while queue:
		row, col, day = queue.popleft()
		max_day = max(max_day, day)
		for dr, dc in directions:
			new_row, new_col = row + dr, col + dc
			if (0 \<= new_row \< n and 
				0 \<= new_col \< m and 
				grid\[new_row\]\[new_col\] == 0):
				grid\[new_row\]\[new_col\] = 1
				unripe_count -= 1
				queue.append((new_row, new_col, day + 1))

	# ì•ˆ ìì€ í† ë§ˆí† ê°€ ë‚¨ì•„ìˆìœ¼ë©´ -1

	return max_day if unripe_count == 0 else -1

# í…ŒìŠ¤íŠ¸ í•¨ìˆ˜

def test_tomato():

	# ì˜ˆì œ 1

	grid1 = \[
		\[0, 0, 0, 0, 0, 0\],
		\[0, 0, 0, 0, 0, 0\],
		\[0, 0, 0, 0, 0, 0\],
		\[0, 0, 0, 0, 0, 1\]
	\]

	# ì •ë‹µ: 8

	# ì˜ˆì œ 2

	grid2 = \[
		\[0, -1, 0, 0, 0, 0\],
		\[-1, 0, 0, 0, 0, 0\],
		\[0, 0, 0, 0, 0, 0\],
		\[0, 0, 0, 0, 0, 1\]
	\]

	# ì •ë‹µ: -1

	# ì˜ˆì œ 3

	grid3 = \[
		\[1, -1, 0, 0, 0, 0\],
		\[0, -1, 0, 0, 0, 0\],
		\[0, 0, 0, 0, -1, 0\],
		\[0, 0, 0, 0, -1, 1\]
	\]

	# ì •ë‹µ: 6

	print("í…ŒìŠ¤íŠ¸ëŠ” ì‹¤ì œ ë°±ì¤€ì— ì œì¶œí•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.")
test_tomato()

```

## ğŸ¯ ë¬¸ì œ 9: ë°±ì¤€ 7569 - í† ë§ˆí†  (3D)

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ìœ„ í† ë§ˆí†  ë¬¸ì œì˜ 3ì°¨ì› ë²„ì „ì…ë‹ˆë‹¤. í† ë§ˆí† ê°€ ì—¬ëŸ¬ ì¸µì— ìŒ“ì—¬ìˆìŠµë‹ˆë‹¤.

### ğŸ’¡ í’€ì´ ì „ëµ

1. 3D BFS (ìœ„, ì•„ë˜ ë°©í–¥ ì¶”ê°€)
2. 6ë°©í–¥ ì´ë™ (ìƒí•˜ì¢Œìš° + ìœ„ì•„ë˜)
3. Multi-source BFS

### ğŸ’» ì½”ë“œ

```

from collections import deque
from typing import List
def solve_tomato_3d():
	"""
	ë°±ì¤€ 7569: í† ë§ˆí†  (3D)
	ë‚œì´ë„: Gold 5
	"""

	# ì…ë ¥: M(x), N(y), H(z)

	m, n, h = map(int, input().split())
	grid = \[\]
	for _ in range(h):
		layer = \[\]
		for _ in range(n):
			layer.append(list(map(int, input().split())))
		grid.append(layer)

	# ì´ˆê¸° ì„¤ì •

	queue = deque()
	unripe_count = 0
	for z in range(h):
		for y in range(n):
			for x in range(m):
				if grid\[z\]\[y\]\[x\] == 1:  # ìì€ í† ë§ˆí† 
					queue.append((z, y, x, 0))  # (z, y, x, day)
				elif grid\[z\]\[y\]\[x\] == 0:  # ì•ˆ ìì€ í† ë§ˆí† 
					unripe_count += 1
	if unripe_count == 0:
		return 0

	# 6ë°©í–¥ ì´ë™ (ì¢Œ, ìš°, ì „, í›„, ìƒ, í•˜)

	directions = \[
		(0, 0, 1), (0, 0, -1),  # xì¶•
		(0, 1, 0), (0, -1, 0),  # yì¶•
		(1, 0, 0), (-1, 0, 0)   # zì¶•
	\]
	max_day = 0
	while queue:
		z, y, x, day = queue.popleft()
		max_day = max(max_day, day)
		for dz, dy, dx in directions:
			nz, ny, nx = z + dz, y + dy, x + dx
			if (0 \<= nz \< h and 
				0 \<= ny \< n and 
				0 \<= nx \< m and 
				grid\[nz\]\[ny\]\[nx\] == 0):
				grid\[nz\]\[ny\]\[nx\] = 1
				unripe_count -= 1
				queue.append((nz, ny, nx, day + 1))
	return max_day if unripe_count == 0 else -1
print("ì‹¤ì œ ë°±ì¤€ì— ì œì¶œí•˜ì—¬ í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”.")

```

## ğŸ† ë¬¸ì œ 10: ë°±ì¤€ 1697 - ìˆ¨ë°”ê¼­ì§ˆ

### ğŸ“ ë¬¸ì œ ì„¤ëª…

ìˆ˜ë¹ˆì´ ë™ìƒê³¼ ìˆ¨ë°”ê¼­ì§ˆì„ í•˜ê³  ìˆë‹¤. ìˆ˜ë¹ˆì€ í˜„ì¬ ì  Nì— ìˆê³ , ë™ìƒì€ ì  Kì— ìˆë‹¤. ìˆ˜ë¹ˆì´ ìˆëŠ” ìœ„ì¹˜ê°€ Xì¼ ë•Œ ê±¸ì–´ê°€ë©´ 1ì´ˆ í›„ì— X-1 ë˜ëŠ” X+1ë¡œ ì´ë™í•˜ê²Œ ë˜ê³ , ìˆœê°„ì´ë™ì„ í•˜ë©´ 1ì´ˆ í›„ì— 2*Xì˜ ìœ„ì¹˜ë¡œ ì´ë™í•˜ê²Œ ëœë‹¤. ìˆ˜ë¹ˆì´ ë™ìƒì„ ì°¾ì„ ìˆ˜ ìˆëŠ” ê°€ì¥ ë¹ ë¥¸ ì‹œê°„ì´ ëª‡ ì´ˆ í›„ì¸ì§€ êµ¬í•˜ë¼.

### ğŸ’¡ í’€ì´ ì „ëµ

1. BFSë¡œ ìµœë‹¨ ì‹œê°„ ì°¾ê¸°
2. 3ê°€ì§€ ì´ë™ ë°©ë²•: X-1, X+1, 2*X
3. ë²”ìœ„: 0 â‰¤ X â‰¤ 100,000

### ğŸ’» ì½”ë“œ

```

from collections import deque
def solve_hide_and_seek():
	"""
	ë°±ì¤€ 1697: ìˆ¨ë°”ê¼­ì§ˆ
	ë‚œì´ë„: Silver 1
	"""
	n, k = map(int, input().split())
	if n == k:
		return 0
	MAX = 100000
	visited = \[False\] \* (MAX + 1)
	queue = deque(\[(n, 0)\])  # (position, time)
	visited\[n\] = True
	while queue:
		pos, time = queue.popleft()

		# 3ê°€ì§€ ì´ë™ ë°©ë²•

		next_positions = \[pos - 1, pos + 1, pos \* 2\]
		for next_pos in next_positions:
			if next_pos == k:
				return time + 1
			if 0 \<= next_pos \<= MAX and not visited\[next_pos\]:
				visited\[next_pos\] = True
				queue.append((next_pos, time + 1))
	return -1

# í…ŒìŠ¤íŠ¸

def test_hide_and_seek():
	test_cases = \[
		(5, 17, 4),   # 5 -\> 10 -\> 9 -\> 18 -\> 17
		(0, 0, 0),    # ì´ë¯¸ ê°™ì€ ìœ„ì¹˜
		(1, 100000, 16),
	\]
	for n, k, expected in test_cases:

		# BFS êµ¬í˜„

		MAX = 100000
		visited = \[False\] \* (MAX + 1)
		queue = deque(\[(n, 0)\])
		visited\[n\] = True
		result = 0
		if n == k:
			result = 0
		else:
			while queue:
				pos, time = queue.popleft()
				next_positions = \[pos - 1, pos + 1, pos \* 2\]
				for next_pos in next_positions:
					if next_pos == k:
						result = time + 1
						queue.clear()
						break
					if 0 \<= next_pos \<= MAX and not visited\[next_pos\]:
						visited\[next_pos\] = True
						queue.append((next_pos, time + 1))
		print(f"N=\{n\}, K=\{k\}: ìµœë‹¨ ì‹œê°„ = \{result\}ì´ˆ (ì˜ˆìƒ: \{expected\}ì´ˆ)")
test_hide_and_seek()

```

---

# âš ï¸ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

BFS êµ¬í˜„ ì‹œ ìì£¼ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ì™€ í•´ê²° ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.


## ğŸš« ì˜¤ë¥˜ 1: ë°©ë¬¸ ì²´í¬ë¥¼ í ì‚½ì… ì „ì— í•˜ì§€ ì•ŠìŒ

### âŒ ì˜ëª»ëœ ì½”ë“œ

```

from collections import deque
def bfs_wrong(graph, start):
	queue = deque(\[start\])
	visited = set()
	while queue:
		node = queue.popleft()

		# ì—¬ê¸°ì„œ ë°©ë¬¸ ì²´í¬ - ë„ˆë¬´ ëŠ¦ìŒ!

		if node in visited:
			continue
		visited.add(node)
		for neighbor in graph\[node\]:
			queue.append(neighbor)  # ì¤‘ë³µ ì¶”ê°€ ê°€ëŠ¥!

```

### âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ

```

from collections import deque
def bfs_correct(graph, start):
	queue = deque(\[start\])
	visited = \{start\}  # ì‹œì‘ì  ë°©ë¬¸ ì²˜ë¦¬
	while queue:
		node = queue.popleft()
		for neighbor in graph\[node\]:
			if neighbor not in visited:
				visited.add(neighbor)  # í ì‚½ì… ì „ì— ë°©ë¬¸ ì²˜ë¦¬!
				queue.append(neighbor)

```

### ğŸ’¡ ì„¤ëª…

íì— ë„£ê¸° **ì „**ì— ë°©ë¬¸ ì²˜ë¦¬í•´ì•¼ ì¤‘ë³µ ë°©ë¬¸ì„ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ê°™ì€ ë…¸ë“œê°€ íì— ì—¬ëŸ¬ ë²ˆ ë“¤ì–´ê°€ ì‹œê°„ ë³µì¡ë„ê°€ ê¸‰ê²©íˆ ì¦ê°€í•©ë‹ˆë‹¤.

## ğŸš« ì˜¤ë¥˜ 2: ë ˆë²¨ ë³„ ì²˜ë¦¬ë¥¼ ì˜ëª» êµ¬í˜„

### âŒ ì˜ëª»ëœ ì½”ë“œ

```

def bfs_level_wrong(root):
	queue = deque(\[root\])
	result = \[\]
	while queue:

		# í˜„ì¬ í í¬ê¸°ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ

		node = queue.popleft()
		result.append(node.val)
		if node.left:
			queue.append(node.left)
		if node.right:
			queue.append(node.right)

	# ë ˆë²¨ êµ¬ë¶„ì´ ì•ˆ ë¨!

	return result

```

### âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ

```

def bfs_level_correct(root):
	if not root:
		return \[\]
	queue = deque(\[root\])
	result = \[\]
	while queue:
		level = \[\]
		level_size = len(queue)  # í˜„ì¬ ë ˆë²¨ì˜ ë…¸ë“œ ìˆ˜

		# í˜„ì¬ ë ˆë²¨ì˜ ëª¨ë“  ë…¸ë“œ ì²˜ë¦¬

		for _ in range(level_size):
			node = queue.popleft()
			level.append(node.val)
			if node.left:
				queue.append(node.left)
			if node.right:
				queue.append(node.right)
		result.append(level)
	return result

```

### ğŸ’¡ ì„¤ëª…

ë ˆë²¨ë³„ ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš° `len(queue)`ë¥¼ ì €ì¥í•´ë‘ê³  í•´ë‹¹ íšŸìˆ˜ë§Œí¼ë§Œ ì²˜ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.

## ğŸš« ì˜¤ë¥˜ 3: ê·¸ë¦¬ë“œ ë°”ìš´ë“œë¦¬ ì²´í¬ ëˆ„ë½

### âŒ ì˜ëª»ëœ ì½”ë“œ

```

def bfs_grid_wrong(grid, start):
	queue = deque(\[start\])
	visited = \{start\}
	directions = \[(0, 1), (1, 0), (0, -1), (-1, 0)\]
	while queue:
		row, col = queue.popleft()
		for dr, dc in directions:
			new_row, new_col = row + dr, col + dc

			# ë°”ìš´ë“œë¦¬ ì²´í¬ ëˆ„ë½!

			if grid\[new_row\]\[new_col\] == 0:  # IndexError ë°œìƒ ê°€ëŠ¥
				queue.append((new_row, new_col))

```

### âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ

```

def bfs_grid_correct(grid, start):
	rows, cols = len(grid), len(grid\[0\])
	queue = deque(\[start\])
	visited = \{start\}
	directions = \[(0, 1), (1, 0), (0, -1), (-1, 0)\]
	while queue:
		row, col = queue.popleft()
		for dr, dc in directions:
			new_row, new_col = row + dr, col + dc

			# ë°”ìš´ë“œë¦¬ ì²´í¬ ë¨¼ì €!

			if (0 \<= new_row \< rows and 
				0 \<= new_col \< cols and 
				(new_row, new_col) not in visited and
				grid\[new_row\]\[new_col\] == 0):
				visited.add((new_row, new_col))
				queue.append((new_row, new_col))

```

### ğŸ’¡ ì„¤ëª…

ê·¸ë¦¬ë“œ íƒìƒ‰ ì‹œ í•­ìƒ ë°°ì—´ ë°”ìš´ë“œë¦¬ë¥¼ ë¨¼ì € ì²´í¬í•´ì•¼ `IndexError`ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ğŸš« ì˜¤ë¥˜ 4: ì‹œì‘ì  ë°©ë¬¸ ì²˜ë¦¬ ëˆ„ë½

### âŒ ì˜ëª»ëœ ì½”ë“œ

```

def bfs_start_wrong(graph, start):
	queue = deque(\[start\])
	visited = set()  # startë¥¼ visitedì— ì¶”ê°€í•˜ì§€ ì•ŠìŒ!
	while queue:
		node = queue.popleft()
		if node in visited:
			continue
		visited.add(node)
		for neighbor in graph\[node\]:
			if neighbor not in visited:
				queue.append(neighbor)

	# ì‹œì‘ì ì´ ë‹¤ì‹œ ë°©ë¬¸ë  ìˆ˜ ìˆìŒ!

```

### âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ

```

def bfs_start_correct(graph, start):
	queue = deque(\[start\])
	visited = \{start\}  # ì‹œì‘ì  ë°©ë¬¸ ì²˜ë¦¬!
	while queue:
		node = queue.popleft()
		for neighbor in graph\[node\]:
			if neighbor not in visited:
				visited.add(neighbor)
				queue.append(neighbor)

```

## ğŸš« ì˜¤ë¥˜ 5: ìµœë‹¨ ê²½ë¡œì—ì„œ ê²½ë¡œë¥¼ ì œëŒ€ë¡œ ì¶”ì í•˜ì§€ ì•ŠìŒ

### âŒ ì˜ëª»ëœ ì½”ë“œ

```

def bfs_path_wrong(graph, start, goal):
	queue = deque(\[(start, \[start\])\])
	visited = \{start\}
	while queue:
		node, path = queue.popleft()
		if node == goal:
			return path
		for neighbor in graph\[node\]:
			if neighbor not in visited:
				visited.add(neighbor)

				# ê²½ë¡œë¥¼ ë³µì‚¬í•˜ì§€ ì•Šê³  ì§ì ‘ ìˆ˜ì •!

				path.append(neighbor)
				queue.append((neighbor, path))  # ë¬¸ì œ!

```

### âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ

```

def bfs_path_correct(graph, start, goal):
	queue = deque(\[(start, \[start\])\])
	visited = \{start\}
	while queue:
		node, path = queue.popleft()
		if node == goal:
			return path
		for neighbor in graph\[node\]:
			if neighbor not in visited:
				visited.add(neighbor)

				# ìƒˆ ë¦¬ìŠ¤íŠ¸ ìƒì„±!

				new_path = path + \[neighbor\]
				queue.append((neighbor, new_path))

```

### ğŸ’¡ ì„¤ëª…

ê²½ë¡œë¥¼ ì¶”ì í•  ë•ŒëŠ” í•­ìƒ **ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±**í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ëª¨ë“  ê²½ë¡œê°€ ê°™ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ ê³µìœ í•˜ê²Œ ë©ë‹ˆë‹¤.

## ğŸš« ì˜¤ë¥˜ 6: ë¯¸ë¡œì—ì„œ ì‹œì‘ì ì´ë‚˜ ë„ì°©ì ì´ ë²½ì¸ ê²½ìš° ì²˜ë¦¬ ì•ˆ í•¨

### âŒ ì˜ëª»ëœ ì½”ë“œ

```

def bfs_maze_wrong(maze, start, end):

	# ì‹œì‘ì ì´ë‚˜ ë„ì°©ì ì´ ë²½ì¸ì§€ í™•ì¸ ì•ˆ í•¨!

	queue = deque(\[start\])
	visited = \{start\}
	while queue:
		pos = queue.popleft()
		if pos == end:
			return True

		# ...

	return False

```

### âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ

```

def bfs_maze_correct(maze, start, end):

	# ì‹œì‘ì ì´ë‚˜ ë„ì°©ì ì´ ë²½ì¸ ê²½ìš° ì²˜ë¦¬

	if maze\[start\[0\]\]\[start\[1\]\] == 1 or maze\[end\[0\]\]\[end\[1\]\] == 1:
		return False
	queue = deque(\[start\])
	visited = \{start\}
	while queue:
		pos = queue.popleft()
		if pos == end:
			return True

		# ...

	return False

```

## âœ… BFS ì²´í¬ë¦¬ìŠ¤íŠ¸

```

# BFS êµ¬í˜„ ì‹œ í™•ì¸ ì‚¬í•­

â˜ íë¥¼ ì‚¬ìš©í•˜ëŠ”ê°€? (deque)
â˜ ì‹œì‘ì ì„ visitedì— ì¶”ê°€í–ˆëŠ”ê°€?
â˜ íì— ë„£ê¸° **ì „**ì— visited ì²´í¬í•˜ëŠ”ê°€?
â˜ ê·¸ë¦¬ë“œì¸ ê²½ìš° ë°”ìš´ë“œë¦¬ ì²´í¬ë¥¼ í•˜ëŠ”ê°€?
â˜ ë ˆë²¨ë³„ ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš° len(queue)ë¥¼ ì €ì¥í–ˆëŠ”ê°€?
â˜ ê²½ë¡œë¥¼ ì¶”ì í•˜ëŠ” ê²½ìš° ìƒˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ëŠ”ê°€?
â˜ ì‹œì‘ì ê³¼ ë„ì°©ì ì´ ìœ íš¨í•œì§€ í™•ì¸í–ˆëŠ”ê°€?
â˜ ë°©í–¥ ë²¡í„°ê°€ ì˜¬ë°”ë¥¸ê°€? (ì˜ˆ: 4ë°©í–¥, 8ë°©í–¥)
â˜ ì¢…ë£Œ ì¡°ê±´ì„ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬í•˜ëŠ”ê°€?
â˜ ëª¨ë“  ì—£ì§€ ì¼€ì´ìŠ¤ë¥¼ ì²˜ë¦¬í–ˆëŠ”ê°€? (ë¹ˆ ê·¸ë˜í”„, ë…¸ë“œ í•˜ë‚˜ ë“±)

```

## ğŸ“Š ì„±ëŠ¥ ìµœì í™” íŒ

### 1. ì ì ˆí•œ ìë£Œêµ¬ì¡° ì‚¬ìš©

```

# âŒ ëŠë¦¼ - listë¡œ visited ê´€ë¦¬

visited = \[\]
if node not in visited:  # O(n) ê²€ìƒ‰
	visited.append(node)

# âœ… ë¹ ë¦„ - setìœ¼ë¡œ visited ê´€ë¦¬

visited = set()
if node not in visited:  # O(1) ê²€ìƒ‰
	visited.add(node)

```

### 2. ë¶ˆí•„ìš”í•œ ë³µì‚¬ í”¼í•˜ê¸°

```

# âŒ ë©”ëª¨ë¦¬ ë‚­ë¹„

queue.append((node, path\[:\]))  # ë¦¬ìŠ¤íŠ¸ ë³µì‚¬

# âœ… parent ë”•ì…”ë„ˆë¦¬ë¡œ ê²½ë¡œ ì¶”ì 

parent\[neighbor\] = node

# ë‚˜ì¤‘ì— ê²½ë¡œ ì¬êµ¬ì„±

```

### 3. ì¡°ê¸° ì¢…ë£Œ

```

# âœ… ëª©í‘œ ë°œê²¬ ì‹œ ì¦‰ì‹œ ë°˜í™˜

if neighbor == goal:
	return construct_path(...)
queue.append(neighbor)

```

---

# ğŸ“š ì°¸ê³  ìë£Œ

## ğŸŒ ì˜¨ë¼ì¸ ë¦¬ì†ŒìŠ¤

### ğŸ“š íŠœí† ë¦¬ì–¼

- [GeeksforGeeks - BFS for a Graph](
```

graph TD
	A\["ğŸ”µ ê¸°ì´ˆ: BFS ê°œë…"\] --\> B\["ğŸŸ¢ ì´ˆê¸‰: ê¸°ë³¸ êµ¬í˜„"\]
	B --\> C\["ğŸŸ¡ ì¤‘ê¸‰: ì‹¤ì „ ë¬¸ì œ"\]
	C --\> D\["ğŸŸ  ê³ ê¸‰: ìµœì í™” ê¸°ë²•"\]
	D --\> E\["ğŸ”´ ë§ˆìŠ¤í„°: ë³µì¡í•œ ë¬¸ì œ"\]
	style A fill:#e1f5ff
	style B fill:#c3f0ca
	style C fill:#fff4c3
	style D fill:#ffe8c3
	style E fill:#ffc3c3

```

## âœ¨ í•µì‹¬ ìš”ì•½

1. **BFSëŠ” ë ˆë²¨ë³„ë¡œ íƒìƒ‰** - í ì‚¬ìš©
2. **ìµœë‹¨ ê²½ë¡œë¥¼ ë³´ì¥** - ê°€ì¤‘ì¹˜ ì—†ëŠ” ê·¸ë˜í”„ì—ì„œ
3. **ì‹œê°„ ë³µì¡ë„ O(V + E)** - íš¨ìœ¨ì 
4. **ë°©ë¬¸ ì²˜ë¦¬ëŠ” í ì‚½ì… ì „** - ì¤‘ë³µ ë°©ì§€
5. **ë‹¤ì–‘í•œ ì‘ìš©** - ê²Œì„, ë„¤íŠ¸ì›Œí¬, AI ë“±

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

- ğŸ’ª **ì—°ìŠµí•˜ê¸°**: LeetCodeì—ì„œ 50ê°œ ë¬¸ì œ í’€ê¸°
- ğŸ¯ **í”„ë¡œì íŠ¸**: Unityë¡œ ê¸¸ì°¾ê¸° AI êµ¬í˜„
- ğŸ“š **ì‹¬í™” í•™ìŠµ**: A* ì•Œê³ ë¦¬ì¦˜ í•™ìŠµ
- ğŸ” **ë³€í˜• ì—°êµ¬**: Dijkstra, Bellman-Ford í•™ìŠµ

## ğŸ’¬ í”¼ë“œë°±

ì´ ê°€ì´ë“œê°€ ë„ì›€ì´ ë˜ì—ˆë‚˜ìš”? í”¼ë“œë°±ì´ë‚˜ ì¶”ê°€ ìš”ì²­ì‚¬í•­ì€ ì–¸ì œë“ ì§€ í™˜ì˜í•©ë‹ˆë‹¤!

---

**í–‰ìš´ì„ ë¹Œì–´ìš”! í–‰ë³µí•œ ì½”ë”© ë˜ì„¸ìš”!** ğŸš€âœ¨

*ì´ ë¬¸ì„œëŠ” 2026ë…„ 1ì›” 15ì¼ì— ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.*