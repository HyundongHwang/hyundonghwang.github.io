---
layout: post
title: "251123 책리뷰 절대강좌 유니티"
comments: true
tags:
- 책리뷰
- Unity
- 유니티
- 게임개발
- 3D게임
- 머티리얼
- 라이팅
- 조명
- 애니메이션
- 메카님
- 리타게팅
- 물리엔진
- RigidBody
- 충돌감지
- 파티클시스템
- 네비게이션
- AI
- NavMesh
- A-Star
- LOD
- 카메라
- Lerp
- Slerp
- 레이캐스트
- 기즈모
- TrailRenderer
- 게임프로그래밍
- C#
- 스크립팅
- 입문서
- 튜토리얼
---

# p70 머티리얼
- Albedo
- Normal Map
- 렌더링 모드
  - Opaque
    - 기본값
    - 불투명한 텍스쳐
  - Cutout
    - 불투명+투명 동시표현
    - 풀, 그물망
  - Transparent
    - 투명한 플라스틱, 유리
  - Fade
    - 투명속성값을 페이드아웃
    - 홀로그램
- HeightMap
  - 노멀맵과 비슷한 기능
  - 좀더 돌출시켜, Occlusion효과가능
- 알베도+노멀맵+하이트맵
- 오클루전(Occlusion)
  - 흑백의 텍스쳐
  - 간접조명의 명암을 더욱 뚜렷히 표시
- 이미션(Emission)
  - 스스로 빛을 방출하는 속성
  - 가운데 방사능 마크부분만 자체발광
- Bumped Diffuse 셰이더
  - 메인텍스쳐와 음영노멀맵
- Bumped Specular
  - 표면의 빛 반사
  - MainColor, SpecularColor, Shininess 변경 테스트

# p99 조명
- Directional Light
  - 균일한 조명
  - 실시간 조명중 가장 저비용
- Point Light
  - 일반 전구
  - Range 속성
    - 빛의 도달 범위
- Spot Light
  - 손전등 같이 Corn모양
  - 실시간 조명중 가장 고비용
- Area Light
  - 라이트를 베이크 해야 확인 가능
  - 실시간 조명이 아님
  - 간접조명

# p102 실시간 라이트 매핑
- LightingSetting 에셋 생성
  - myLightSetting
- AutoGenerate 옵션 체크

# p104 하늘표현방식
- SkyBox
  - 육면체
  - 머터리얼생성
    - matMySkyBox
  - SkyBox/6Sided 쉐이더 연결
  - 6개의 텍스쳐 연결
  - myLightSetting.skyBoxMaterial = matMySkyBox
- SkyDome
  - 돔형태
- 프로시저럴 스카이박스
  - ProceduralSkyBox
  - 텍스쳐 없이 하늘색상, 대기농도, 노출, 태양위치 설정
  - 머터리얼생성
    - matSkyBox2
  - 속성
    - Sun
      - None
      - Simple
      - High Quality
    - SunSize
    - AtmosphereThickness
    - SkyTint
    - Exposure
  - myLightSetting.skyBoxMaterial = matMySkyBox2
  - 씬뷰의 DirectLight의 trs.rotation을 변경
  - 태양의 위치 변경 확

# p141 Time.deltaTime
- 프레임레이트가 다른환경에서 동일한 속도로 이동
```c#
Update
    tr.Translate(Vector3.forward * Time.deltaTime * 10)
```

# p149 정규화 벡터 이용
```c#
Update
    h = Input.GetAxis("Horizontal")
    v = Input.GetAxis("Vertical")
    moveDir = Vector3.forward * v + Vector3.right * h
    tr.Translate(moveDir.normalized * Time.deltaTime * _moveSpeed)
```

# p152 마우스 좌우 이동에 따른 회전처리
```c#
Update
    h = Input.GetAxis("Horizontal")
    v = Input.GetAxis("Vertical")
    r = Input.GetAxis("Mouse X")
    moveDir = Vector3.forward * v + Vector3.right * h
    tr.Translate(moveDir.normalized * Time.deltaTime * _moveSpeed)
    tr.Rotate(Vector.up * Time.deltaTime * r * _turnSpeed)
```

# p154 애니메이션
- 레거시 애니메이션
  - 소스코드로 컨트롤
  - Animation 컴포넌트
- 메카님 애니메이션
  - 모션 캡쳐 애니메이션
  - 리타게팅
  - 종류
    - Generic
      - 인체모델 아닌 3D 모델
      - 리타게팅 불가
    - Humanoid
      - 2족보행 3D 모델
      - 리타게팅 가능
- 애니메이션 클립
  - 걷기, 달리기, 점프, 총쏘기 같은 동작 기록 파일
  - 애니메이션 컴포넌트는 애니메이션 클립에 기록된 관절위치 회전값을 프레임 단위로 재생
- 3D모델툴에서 제작한 애니매이션 클립을 애니메이션 파일로 만드는 방법
  - 모든 애니메이션 클립이 하나의 애니메이션 파일
  - 미리 분리된 경우
  - 애니메이션 클립을 동작별로 별도의 파일
    - 모델명@애니메이션클립
    - FallenAngel@Attack1
    - FallenAngel@Rage
- Player.Animation.Animations 에 애니메이션 클립들을 연결
  - Idle
  - IdleFireSMG
  - ...
```
Start
    ani = GetComponent<Animation>()
    ani.Play("Idle")
```

# p166 애니메이션 블랜딩
```
ani.CrossFade("RunF", 0.25F)
```

# p172 그림자
- 실시간 그림자
  - DirLight, PointLight, SpotLight 세가지 광원에 대해 실시간 그림자 지원
- ShadowType
  - No
  - Hard
    - 실시간
    - 하지만 외곽선 계단현상
  - Soft
    - 실시간
    - 부드러운 외곽선
    - 고비용
- 3D모델.MeshRenderer
  - CastShadow
    - Off
    - On
      - 그림자 생성
    - TwoSided
      - 백스페이스 컬링 무시
      - 그림자를 양면으로 생성
    - ShadowsOnly
      - 그림자는 생성
      - 자신은 렌더링 안함
      - 그림자 처리만을 위한 로우폴리 모델
  - RecvShadow 
    - 다른그림자에 들어갔을때 처리

# p175 메시를 이용한 그림자
- 실시간보다는 시각적효과 약함
- 그래도 입체감 가능한 가벼운 그림자처리
- 단순한 평면 메시 사용
- 모바일게임에 흔함.
- 과정
  - player.ShadowType = No
  - 세개의 메시 모두 선택
  - SkinnedMeshRenderer
    - CastShadow = off
    - RecvShadow = off
  - 발바닥에 Quad 추가
    - trs.y = 0.01
    - Collider 컴포턴트 삭제
    - BlobShadow 텍스쳐 추가
    - Shader : "Particles/Multiply"

# p180 LOD
- Level Of Detail
- 과정
  - player.LODGroup
    - LOD0
      - 하이 폴리곤
    - LOD1
    - LOD2
    - LOD3
      - 로우 폴리곤

# p184 Follow Camera 로직
```
FollowCam
    Update
        tr.position = _targetTr.position + targetTr.backward * _distance + Vector3.up * _height
        tr.LookAt(_targetTr.position) 
```

# p189 Lerp, Slerp
```
FollowCam
    Update
        pos = _targetTr.position + targetTr.backward * _distance + Vector3.up * _height
        tr.position = Vector3.Slerp(tr.position, pos, Time.deltaTime * _damping)
        tr.LookAt(_targetTr.position) 
```

# p199 총발사 로직
- Projectile 방식
  - 물리적으로 발사
  - 게임속도 저하
  - 총알은 로우폴리모델
- RayCast 방식
  - FPS게임의 저격용총
  - 광선발사
  - 물체를 검출하는 방식
  - 로봇의 센서
  - 추적기능

# p202 RigidBody
- UseGravity
  - 언체크
  - 총알이 중력의 영향을 받지 않고 날아가도록
- 속성
  - Mass
    - 질량
    - 1kg 단위
  - Drag
    - 이동 마찰계수
  - AngularDrag
    - 회전 마찰계수
  - UseGravity
  - IsKinematic
    - 물리시뮬레이션을 통해 이동하지 않고, 트랜스폼을 통해 이동함
    - 물리엔진의 영향을 받지 않음
  - Interpolate
    - 부드럽게 처리
  - CollisionDetection
    - 충돌감지옵션
    - 세밀한 충돌 검출 옵션
  - FreezePosition
    - xyz 축 중 이동 제한
  - FreezeRotation
    - xyz 축 중 이동 제한

- 월드좌표기준
```c#
rb.AddForce(tr.forward * _force)
```

- 로컬좌표기준
```c#
rb.AddRelativeForce(tr.forward * _force)
```

# p215 충돌이벤트
- IsTrigger=off
  - OnCollisionEnter
  - OnCollisionStay
  - OnCollisionExit
- IsTrigger=on
  - OnTriggerEnter
  - OnTriggerStay
  - OnTriggerExit
- IsTrigger=on
  - 충돌감지는 되지만 물리적인 충돌은 없음.
  - 서로 부딧혀 정지하거나 튕기는 현상 없음.
  - 벽을관통
  - 감지센서
    - 슬라이딩 도어가 열림
    - 적이 생성됨

# p225 기즈모 활용
- 기즈모는 유니티 에디터에서만, 실행시 안보임
```c#
MyGizmos : MonoBehavior
    OnDrawGizmos
        Gizmos.color = _color
        Gizmos.DrawSpahre(tr.position, _radius)
```

- 인스펙터의 아이콘기능도 기즈모와 비슷한 기

# p231 총알발사궤적효과 - TrailRenderer
- TrailRenderer
  - 쉐이더 : Particle/Additive
  - MinVertexDistance
    - 작을수록 조밀한 효과

# p239 파티클 활용하기
- 에셋스토어 UnityParticlePack
```c#
OnCollisionEnter(Collision coll)
    Instantiate
```

# p244 충돌지점과 법선벡터 산출
```c#
OnCollisionEnter(Collision coll)
    cp = coll.GetContact(0)
    rot = Quaternion.LookRotation(-cp.normal)
    Instantiate(_sparkEffect, cp.point, rot)
    Destroy(coll.gameObject)
```

# p268 폭발반경 계산
```c#
collList = Physics.OverlapSphere(this.transform.position, _radius)

foreach(coll in collList)
    rb = coll.GetComponent<RigidBody>()
    rb.mass = 1.0F
    rb.constraints = RigidbodyConstraints.None
    rb.AddExplosionForce(1500F, this.transform.position, 1200F)
```

# p308 메카님
- 애니메이션 미들웨어 엔진
- 유연한 애니메이션 처리
- 리타게팅 제공
- Humanoid 모델의 Bone 구조와 일치하면 모션캡쳐 애니메이션 바로 적용
- 에셋스토어의 모션캡쳐 애니메이션
  - Runner Action Animation Pack
- 몬스터 3D 모델 임포트
  - Monster 패키지 임포트
  - AnimationType
    - 휴머노이드 선택
      - 리타게팅 가능
    - 모델본과 매핑된 결과 보여줌
    - 실선으로 되어 있는원과 필수연결 본은 15개
    - 관절을 미리 움직여서 어색한 부분 찾기 가능
  - Animation탭
    - Clips
      - idle
      - walk
      - attack
      - ...

# p315 애니메이션 리타게팅
- maximo.com
- 강남스타일 애니메이션 검색
- 지금 작업중인 Monster.fbx 를 업로드해서 애니메이션 적

# p318 Animator 컴포넌트
- 3D 모델에 추가하는 컴포넌트
  - Animator
    - 메카님 애니메이션
    - 세부옵션
      - 제너릭
      - 휴머노이드
  - Animation
    - 레거시 애니메이션
- Animator 컴포넌트 속성
  - Controller
    - 애니메이션 클립간 연결정보 저장
    - Animator Controller 연결
  - Avatar
    - 본매핑정보를 저장한 Avatar 에셋 연결
  - Apply Root Motion
    - 애니메이션 클립에 저장된 위치와 회전값 적용여부
  - Update Mode
  - Culling Mode

# p321 애니메이터 컨트롤러
- 몬스터에 애니메이션 기능 추가
- 에셋으로 AnimatorController 추가
  - MonsterAnim
- 애니메이터 뷰
  - 3개의 스테이트
    - AnyState
    - Entry
    - Exit
- idle 스테이트 추가
- Monster.Controller = MonsterAnim
- idle, walk 애니메이션을 애니메이터뷰로 드래그앤드롭

# p328 네비게이션 - 적캐릭터의 순찰 추적
- 길찾기알고리즘
  - 가장 많이 알려진 알고리즘 
    - A* Pathfinding
    - 에셋스토어 A* Pathfinding
- 네이게이션 구현방식
  - 스테이지를 구성하고 있는 3D 메시를 분석해서 NavMesh 데이타를 미리생성
  - 추적할수 있는 영역과 장애물 영역을 데이타로 미리 메시로 만드는 것

# p330 네비게이션 설정 - Navigation Static Flag
- 바닥 Floor Static 옵션 설정
  - Navigation Static 지정

# p332 NavMeshAgent 컴포넌트
- 내비메시 데이타를 기반으로 목적지까지 최단거리 계산
- 장애물과 충돌 회피
- A* Pathfinding 알고리즘 기반
- Monster 오브젝트에 NavMeshAgent 컴포넌트 추가
  - 속성
    - AgentType
      - 장애물을 회피할수 있는 회피할 수 있는 계단의 높이, 경사로 각도
      - 기본값 : Humanoid
    - BaseOffset
      - 표면에 붙어서 이동
      - 높낮이를 조절하는 기능
    - Speed
    - AngularSpeed
    - AutoBaking
      - 목표지점에 가까워 졌을때 속도를 줄이는 기능
      - 부드러운 이동을 위해서는 off
```c#
Start
    agent = monster.GetComponent<NavMeshAgent>()
    agent.destination = playerTr.position
```

# p541 DrawRay
- 레이캐스트는 시각적으로 표시되지 않아서, 개발할때는 DrawRay 함수 사용하여 시각화
```c#
Update
    Debug.DrawRay(fireTr.position, fireTr.forward * 10F, Color.green)
    if (Input.GetMouseButtonDown(0))
        if (Physics.Raycast(fireTr.position, fireTr.forward, out hit, 10F))
            Debug.Log($"hit:{hit.transform.name}")
            monster = hit.transform.GetComponent<Monster>()
            if (monster != null)
                monster.OnDamage(hit.point, hit.normal)
```