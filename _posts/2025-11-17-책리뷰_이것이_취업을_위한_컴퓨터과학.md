---
layout: post
title: "251117 책리뷰 이것이 취업을 위한 컴퓨터과학"
comments: true
tags: []
---

# p66 CPU

# p66 레지스터
- WinDbg, gdb
- 프로그램카운터(PC, Program Counter)
  - 메모리에서 다음으로 읽어들일 명령어 주소
- 명령어레지스터(IC, Instruction Register)
  - 해석할 명령어
  - CPU는 IC속 명령어를 해석한뒤, ALU(산술 논리 연산 장치)에게 연산시킴.
- 범용레지스터(GPR, General Purpose Register)
  - 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
  - 데이터, 명령어, 주소 모두 저장.
- 플래그 래지스터(FR, Frag Register)
  - 연산의 결과 
  - CPU 상태인 플래그값을 저장하는 레지스터
- 플래그 종류
  - 부호플래그
  - 제로플래그
  - 캐리플래그
  - 오버플로우플래그
  - 인터럽트플래그
    - 인터럽트가 가능한지
  - 슈퍼바이져플래그
    - 커널모드인지 사용자모드인지
- 스텍포인터

# p70 인터럽트
- 동기인터럽트
- 비동기인터럽트 = 하드웨어 인터럽트
  - 입출력장치
  - 세탁기의 세탁완료알림
  - 프린터 알림
  - 키보드 마우스 알림

# 하드웨어 인터럽트
- CPU가 인터럽트 처리하는 순서
  - 입출력장치 -> CPU : 인터럽트 요청신호
  - CPU : 명령어인출전, 인터럽트 여부 확인
  - CPU : 인터럽트 플래그를 통해 인터럽트 입력받을 수 있는지 확인
  - CPU : 지금까지 작업을 백업
  - CPU : 인터럽트 서비스 루틴 실행
  - CPU : 백업된 작업을 복구하여 실행

# p76 예외
- 인터럽트
  - 동기 인터럽트(=예외)
    - 폴트
    - 트랩
    - 중단
    - 소프트웨어 인터럽트
  - 비동기 인터럽트(=하드웨어 인터럽트)
- 폴트
  - 예외를 처리한 직후, 예외가 발생한 명령어부터 실행
  - 페이지 폴트
- 트랩
  - 예외를 처리한 직후, 예외가 발생한 다음 명령어부터 실행
  - 디버깅의 브레이크 포인트
- 중단
  - 프로그램을 강제로 중단
  - 심각한 오류

# p78 CPU 성능향상을 위한 설계
- 클럭
- 코어
- 스레드
- 동시성, 병렬성

# p78 CPU 클럭속도

# p79 멀티코어 멀티스레드
- $ cat /proc/cpuinfo
- 병렬성
  - 작업을 물리적으로 동시에 처리
  - 하드웨어 스레드가 4개인 CPU가 4개의 명령어를 동시 실행
  - 같은 시점에 여러 작업을 동시 처리
- 동시성
  - 동시에 작업을 처리하는 것
  - CPU가 빠르게 작업을 번갈아 처리

# p85 파이프라이닝을 통한 명령어 병렬처리
- 명령어 병렬 처리 기법
  - ILP
  - Instruction Level Parallelism
  - 여러 명령어를 동시에 처리하여 CPU 성능을 높이는 기법
  - 명령어 파이프라이닝
- 하나의 명령어가 처리되는 과정
  - 명령어 인출 : Instruction Fetch
  - 명령어 해석 : Instruction Decode
  - 명령어 실행 : Execute Instruction
  - 결과 저장 : Write Back
- 슈퍼스칼라
  - CPU내부에 여러 명령어 파이프라인을 포함하는 구조 = 슈퍼스칼라
- CISC, RISC

# p90 메모리

# p90 RAM
- DRAM
  - Dynamic RAM
  - 시간이 지나면 데이타가 점차 사라지는 RAM
  - 데이타의 소멸을 막기 위해 일정 주기로 데이타를 재활성화(다시 저장) 필요
  - 소비전력이 작고, 저렴, 집적도 높음.
- SRAM
  - Static RAM
  - 시간이 지나도 저장된 데이타가 사라지지 않는 RAM
  - 비휘발성은 아님.
  - 전원이 공급되지 않으면 저장된 내용이 소실.
  - DRAM보다 속도 빠름, 소비전력 높음, 고가, 집적도 낮음.
  - 캐시메모리
- SDRAM
  - Synchronized DRAM
- DDR SDRAM
  - Double Data Rate SDRAM

# p93 빅엔디안, 리틀엔디안
- 빅엔디안
  - 낮은 번지에 상위바이트 저장
  - 상위바이트는 가장큰값
  - 1A2B3C4D -> 1A 2B 3C 4D
  - 일상적인 숫자체계를 읽는 순서와 동일
  - 디버깅 편함

```python
import struct

print(struct.pack(">f", 123.456).hex())
```

- 리틀엔디안
  - 낮은 번지에 하위 바이트 저장
  - 1A2B3C4D -> 4D 3C 2B 1A
  - 수치계산 편리

```python
import sys

print(sys.byteorder)
```

# p97 캐시메모리

# p107 보조기억장치와 입출력장치

# 107 RAID
- 하드 디스크 드라이브
- 플래시 메모리 기반 저장장치
  - USB 메모리
  - SD 카드
  - SSD (Solid State Drive)
- RAID
  - Redundant Array Independant Disk
- RAID0
  - 단순하게 나누어 저장하는 구성방식
  - 저장된 정보가 안전하지 않음.
- RAID1
  - 완전한 복사본 저장
  - 미러링
  - 복구가 간단 안전성 높음
  - 사용가능한 용량이 적어짐
- RAID4
  - 패리티 정보를 저장하는 디스크를 따로 구성
  - 패리티 디스크가 병목

# p113 입출력기법
- 인터럽트 기반 입출력 
- PIC
  - Programmable Interrupt Controller
- IRQ
  - 인터럽트 요청
- DMA 입출력
  - Direct Memory Access
  - CPU를 거치지 않음.

# p123 GPU 용도와 처리방식
- GPGPU
  - General Purpose GPU
- CUDA
  - host code
    - CPU가 실행할 코드
  - device code
    - GPU가 실행할 코드

# p134 운영체제

# p135 운영체제의 역할

# p138 시스템콜과 이중모드
- 커널영역
- 사용자영역
- 프로세스 관리
  - fork()
  - execve()
  - exit()
  - waitpid()
  - ...

# p144 프로세스와 스레드
- 포그라운드 스레드
- 백그라운드 스레드
  - 서비스
  - 데몬
- 메모리
  - 커널영역
    - PCB : Process Control Block
  - 유저영역
    - 스택
    - 힙
    - 데이타
    - 코드

# p150 프로세스의 상태
- 생성
- 준비
  - --> 실행 : 디스패치
- 실행
  - --> 준비 : 타이머인터럽트
  - --> 대기 : 입출력요청
- 대기
  - --> 준비 : 입출력완료
- 종료

# p152 멀티프로세스와 멀티스레드

# p158 프로세스간 통신
- 공유메모리
  - 마치 자신의 메모리 영역을 읽고 쓰는것 처럼 통신
  - 커널의 개입이 없음.
  - 통신속도 빠름.
  - 레이스 컨디션 발생 여지.
- 메시지전달
  - 파이프, 시그널, 소켓, RPC
- 파이프
  - unnamed pipe
  - named pipe
- 시그널
  - SIGILL
    - 허용하지 않은 명령어 실행
    - 코어덤프후 종료
  - SIGINT
    - 키보드 인터럽트
    - 종료
  - SIGKILL
    - 프로세스 종료
    - 핸들러 재정의 불가능
  - SIGSEGV
    - 잘못된 메모리 접근
    - 코어덤프 생성후 종료
  - SIGTERM
    - 프로세스 종료
    - 핸들러 재정의 가능

```python
import ctypes
ctypes.string_at(0)
```

```bash
$ coredumpctl info
PID ...
UID ...
Signal : 11 SEGV
Command Line : python ...
...
```

# p165 동기화와 교착상태

# p170 동기화 기법
- 뮤텍스 락
  - lock.acquire()
  - lock.release()

```c
include <pthred.h>

pthread_mutex_t mutex

pthread_mutex_init(&mutex)

pthread_mutex_lock(&mutex)
pthread_mutex_unlock(&mutex)

pthread_mutex_destroy(&mutex)
```

```java
lock = new ReenterantLock()

lock.lock()
lock.unlock()
```