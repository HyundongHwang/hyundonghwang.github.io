---
layout: post
title: "251117 책리뷰 이것이 취업을 위한 컴퓨터과학"
comments: true
tags: [책리뷰, 컴퓨터과학, CS, 취업준비, 기술면접, CPU, 메모리, 운영체제, OS, 프로세스, 스레드, 인터럽트, 가상메모리, 페이징, 스케줄링, 동기화, 뮤텍스, 세마포, 교착상태, 자료구조, 알고리즘, 네트워크, 데이터베이스, DB, SQL, ACID, 정규화, 인덱스, MongoDB, Redis, NoSQL, 기초이론, 면접준비]
---

# p66 CPU

# p66 레지스터
- WinDbg, gdb
- 프로그램카운터(PC, Program Counter)
  - 메모리에서 다음으로 읽어들일 명령어 주소
- 명령어레지스터(IC, Instruction Register)
  - 해석할 명령어
  - CPU는 IC속 명령어를 해석한뒤, ALU(산술 논리 연산 장치)에게 연산시킴.
- 범용레지스터(GPR, General Purpose Register)
  - 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
  - 데이터, 명령어, 주소 모두 저장.
- 플래그 래지스터(FR, Frag Register)
  - 연산의 결과 
  - CPU 상태인 플래그값을 저장하는 레지스터
- 플래그 종류
  - 부호플래그
  - 제로플래그
  - 캐리플래그
  - 오버플로우플래그
  - 인터럽트플래그
    - 인터럽트가 가능한지
  - 슈퍼바이져플래그
    - 커널모드인지 사용자모드인지
- 스텍포인터

# p70 인터럽트
- 동기인터럽트
- 비동기인터럽트 = 하드웨어 인터럽트
  - 입출력장치
  - 세탁기의 세탁완료알림
  - 프린터 알림
  - 키보드 마우스 알림

# 하드웨어 인터럽트
- CPU가 인터럽트 처리하는 순서
  - 입출력장치 -> CPU : 인터럽트 요청신호
  - CPU : 명령어인출전, 인터럽트 여부 확인
  - CPU : 인터럽트 플래그를 통해 인터럽트 입력받을 수 있는지 확인
  - CPU : 지금까지 작업을 백업
  - CPU : 인터럽트 서비스 루틴 실행
  - CPU : 백업된 작업을 복구하여 실행

# p76 예외
- 인터럽트
  - 동기 인터럽트(=예외)
    - 폴트
    - 트랩
    - 중단
    - 소프트웨어 인터럽트
  - 비동기 인터럽트(=하드웨어 인터럽트)
- 폴트
  - 예외를 처리한 직후, 예외가 발생한 명령어부터 실행
  - 페이지 폴트
- 트랩
  - 예외를 처리한 직후, 예외가 발생한 다음 명령어부터 실행
  - 디버깅의 브레이크 포인트
- 중단
  - 프로그램을 강제로 중단
  - 심각한 오류

# p78 CPU 성능향상을 위한 설계
- 클럭
- 코어
- 스레드
- 동시성, 병렬성

# p78 CPU 클럭속도

# p79 멀티코어 멀티스레드
- $ cat /proc/cpuinfo
- 병렬성
  - 작업을 물리적으로 동시에 처리
  - 하드웨어 스레드가 4개인 CPU가 4개의 명령어를 동시 실행
  - 같은 시점에 여러 작업을 동시 처리
- 동시성
  - 동시에 작업을 처리하는 것
  - CPU가 빠르게 작업을 번갈아 처리

# p85 파이프라이닝을 통한 명령어 병렬처리
- 명령어 병렬 처리 기법
  - ILP
  - Instruction Level Parallelism
  - 여러 명령어를 동시에 처리하여 CPU 성능을 높이는 기법
  - 명령어 파이프라이닝
- 하나의 명령어가 처리되는 과정
  - 명령어 인출 : Instruction Fetch
  - 명령어 해석 : Instruction Decode
  - 명령어 실행 : Execute Instruction
  - 결과 저장 : Write Back
- 슈퍼스칼라
  - CPU내부에 여러 명령어 파이프라인을 포함하는 구조 = 슈퍼스칼라
- CISC, RISC

# p90 메모리

# p90 RAM
- DRAM
  - Dynamic RAM
  - 시간이 지나면 데이타가 점차 사라지는 RAM
  - 데이타의 소멸을 막기 위해 일정 주기로 데이타를 재활성화(다시 저장) 필요
  - 소비전력이 작고, 저렴, 집적도 높음.
- SRAM
  - Static RAM
  - 시간이 지나도 저장된 데이타가 사라지지 않는 RAM
  - 비휘발성은 아님.
  - 전원이 공급되지 않으면 저장된 내용이 소실.
  - DRAM보다 속도 빠름, 소비전력 높음, 고가, 집적도 낮음.
  - 캐시메모리
- SDRAM
  - Synchronized DRAM
- DDR SDRAM
  - Double Data Rate SDRAM

# p93 빅엔디안, 리틀엔디안
- 빅엔디안
  - 낮은 번지에 상위바이트 저장
  - 상위바이트는 가장큰값
  - 1A2B3C4D -> 1A 2B 3C 4D
  - 일상적인 숫자체계를 읽는 순서와 동일
  - 디버깅 편함

```python
import struct

print(struct.pack(">f", 123.456).hex())
```

- 리틀엔디안
  - 낮은 번지에 하위 바이트 저장
  - 1A2B3C4D -> 4D 3C 2B 1A
  - 수치계산 편리

```python
import sys

print(sys.byteorder)
```

# p97 캐시메모리

# p107 보조기억장치와 입출력장치

# 107 RAID
- 하드 디스크 드라이브
- 플래시 메모리 기반 저장장치
  - USB 메모리
  - SD 카드
  - SSD (Solid State Drive)
- RAID
  - Redundant Array Independant Disk
- RAID0
  - 단순하게 나누어 저장하는 구성방식
  - 저장된 정보가 안전하지 않음.
- RAID1
  - 완전한 복사본 저장
  - 미러링
  - 복구가 간단 안전성 높음
  - 사용가능한 용량이 적어짐
- RAID4
  - 패리티 정보를 저장하는 디스크를 따로 구성
  - 패리티 디스크가 병목

# p113 입출력기법
- 인터럽트 기반 입출력 
- PIC
  - Programmable Interrupt Controller
- IRQ
  - 인터럽트 요청
- DMA 입출력
  - Direct Memory Access
  - CPU를 거치지 않음.

# p123 GPU 용도와 처리방식
- GPGPU
  - General Purpose GPU
- CUDA
  - host code
    - CPU가 실행할 코드
  - device code
    - GPU가 실행할 코드

# p134 운영체제

# p135 운영체제의 역할

# p138 시스템콜과 이중모드
- 커널영역
- 사용자영역
- 프로세스 관리
  - fork()
  - execve()
  - exit()
  - waitpid()
  - ...

# p144 프로세스와 스레드
- 포그라운드 스레드
- 백그라운드 스레드
  - 서비스
  - 데몬
- 메모리
  - 커널영역
    - PCB : Process Control Block
  - 유저영역
    - 스택
    - 힙
    - 데이타
    - 코드

# p150 프로세스의 상태
- 생성
- 준비
  - --> 실행 : 디스패치
- 실행
  - --> 준비 : 타이머인터럽트
  - --> 대기 : 입출력요청
- 대기
  - --> 준비 : 입출력완료
- 종료

# p152 멀티프로세스와 멀티스레드

# p158 프로세스간 통신
- 공유메모리
  - 마치 자신의 메모리 영역을 읽고 쓰는것 처럼 통신
  - 커널의 개입이 없음.
  - 통신속도 빠름.
  - 레이스 컨디션 발생 여지.
- 메시지전달
  - 파이프, 시그널, 소켓, RPC
- 파이프
  - unnamed pipe
  - named pipe
- 시그널
  - SIGILL
    - 허용하지 않은 명령어 실행
    - 코어덤프후 종료
  - SIGINT
    - 키보드 인터럽트
    - 종료
  - SIGKILL
    - 프로세스 종료
    - 핸들러 재정의 불가능
  - SIGSEGV
    - 잘못된 메모리 접근
    - 코어덤프 생성후 종료
  - SIGTERM
    - 프로세스 종료
    - 핸들러 재정의 가능

```python
import ctypes
ctypes.string_at(0)
```

```bash
$ coredumpctl info
PID ...
UID ...
Signal : 11 SEGV
Command Line : python ...
...
```

# p165 동기화와 교착상태

# p170 동기화 기법
- 뮤텍스 락
  - lock.acquire()
  - lock.release()

```c
include <pthred.h>

pthread_mutex_t mutex

pthread_mutex_init(&mutex)

pthread_mutex_lock(&mutex)
pthread_mutex_unlock(&mutex)

pthread_mutex_destroy(&mutex)
```

```java
lock = new ReenterantLock()

lock.lock()
lock.unlock()
```

# p174 세마포

# p189 교착상태
- 교착상태 발생조건
  - 상호 배제
    - 한번에 하나의 프로세스만 해당자원을 이용가능
  - 점유와 대기
    - 한 프로세스가 점유한 상태에서 다른 자원할당을 대기
  - 비선점
    - 해당 자원을 이용하는 프로세스의 작업이 끝나야 자원이용가능
  - 원형 대기
    - 프로세스와 프로세스가 요청한 자원이 원의 형태를 이루는 경우

# p193 CPU 스케줄링

# p193 우선순위
- CPU 버스트
- 입출력 버스트
- 입출력 집중 프로세스를 가능한 빨리 실행시키고, CPU집중 프로세스에 집중적으로 CPU를 할당.

# p202 리눅스 CPU 스케줄링
- 리눅스에서는 프로세스마다 vruntime(virtual runtime, 가상 실행 시간)이라는 정보를 유지
- CFS(Completely Fair Scheduler) 는 vruntime이 가장 작은 프로세스부터 스케줄링함.
- vruntime은 실제실행시간이 아닌 가중치를 고려한 가상의 실행시간.
- vruntime = CPU시간 * 평균가중치 / 프로세스가중치
- vruntime, 가중치 정보 확인
  - /proc/<PID>/sched
- vruntime 최소값 빠르게 골라내기
  - RB트리 사용

# p205 가상메모리
- 논리주소
- 물리주소
- 가상메모리
- 페이징

# p205 물리주소 논리주소
- 메모리관리장치 (MMU)
  - CPU와 메모리 사이에 위치

# p206 스와핑과 메모리 연속 할당
- 스와핑
  - 오랫동안 사용되지 않는 프로세스를 스왑영역이라는 보조기억장치로 이동시킴.
  - 메모리의 빈자리에 다른 프로세스를 적재 하여 실행.

# p209 페이지을 통한 가상메모리 관리
- 가상메모리 관리 기법
  - 페이징
    - 페이징이 외부단편화를 어떻게 해결하는지?
  - 세그멘테이션

# p210 페이징
- 프로세스의 논리주소공간을 페이지로 분할
- 물리주소공간을 페이지와 동일한 크기의 프레임으로 분할
- 페이지를 프레임에 할당
- 가상메모리 관리기법
- 스와핑
  - 스왑아웃 : 페이지아웃
  - 스왑인 : 페이지인

# p211 세그멘테이션
- 프로세스를 일정한크기의 페이지가 아닌 세그먼트단위로 분할
- 세그먼트의 크기가 일정하지 않아서 외부 단편화가 발생할 수 있음.

# p213 페이지테이블
- 프로세스의 페이지와 실제의 프레임을 연결해주는 페이지 테이블
- 페이지테이블 
  - 페이지번호
  - 프레임번호
  - 유효비트
    - 해당페이지에 접근가능한지 여부
    - 1 : 페이지가 메모리에 적재되어 있음.
  - 보호비트 rwx
  - 참조비트
  - 수정비트
- 메모리 접근 횟수
  - 모든 프로세스의 페이지 테이블이 메모리에 적재 되어 있을경우
  - CPU는 페이지테이블에 접근, 실제프레임에 접근하기위해 총 2번 메모리에 접근
  - 이를 해결하기위해 TLB(Translation Look-aside Buffer)라는 페이지테이블의 캐시메모리 사용.
  - TLB 히트, 미스

# p221 페이지 교체 알고리즘
- 요구페이징
  - 메모리에 필요한 페이지만 적재하는 방법
  - 기본동작순서
    - 특정페이지에 접근
    - 해당페이지가 메모리에 있을경우(유효비트1)
      - 페이지가 적재된 프레임에 접근
    - 해당페이지가 메모리에 없을경우(유효비트0)
      - 페이지폴트 발생
      - 페이지폴트 처리루틴 수행
      - 해당 페이지를 메모리로 적재
      - 유효비트1로 설정
  - 종류
    - 순수요구페이징
      - 첫명령어를 수행하는 순간, 페이지폴트 발생
      - 언젠가는 메모리가 가득참
      - 일부페이지는 스왑
      - 메모리의 페이지를 보조기억장치로 내보냄
      - 페이지교체 알고리즘
        - FIFO
        - LRU

# p223 파일시스템

# p223 파일과 디렉터리
- 파일 디스크립터
  - 0 : stdin
    - 키보드 입력
  - 1 : stdout
    - 모니터 출력
  - 2 : stderr
    - 표준 에러
- 파일 핸들

# p244 기술면접질문
- 코드의 문제
  - 공유데이타가 동시에 수행되는 과정에서 발생하는 레이스 컨디션 문제
  - 임계구역에서 연산이 하나씩 수행되지 않음.
  - 데이타의 일관성 보장 안됨.
- 코드의 문제 해결
  - pthread_mutex_t mutex 
  - pthread_mutex_lock(&mutex)
  - pthread_mutex_unlock(&mutex)
  - mutex를 활용해 공유자원에 대한 접근 동기화
- 공유메모리기반 IPC가 소켓통신보다 빠른 이유
  - 공유메모리는 메모리공간에 직접접근하기 때문에
  - 마치 자신의 메모리 공간을 읽고 쓰는 것처럼 IPC가 발생
  - 소켓통신은 커널을 통하므로 추가적인 오버헤드 발생
- 운영체제가 메모리에 적재되기까지 과정(부팅의 과정)
  - CPU : ROM에 저장된 BIOS 실행
  - BIOS : 하드디스크의 MBR을 읽고, 부트로더 로드
  - 부트로더 : 커널위치를 RAM에 적재
- 커널
  - 하드웨어와 응용프로그램간의 중재자 역할
  - 프로세스, 스레드 실행
  - CPU, 메모리, 스토리지 등의 하드웨어를 공정하게 할당
  - 커널모드, 유저모드
- thread unsafe 문제
  - 다중스레드에서 레이스 컨디션 발생
  - 데이타 일관성 깨짐
- 리눅스에서 일반적인 사용자프로세스가 CPU를 할당받는 과정
  - 각 프로세스가 가상 실행시간인 vruntime을 유지
  - vruntime이 가장 작은 프로세스부터 스케줄링
  - vruntime은 실제실행시간과 우선순위에 따른 가중치를 고려하여 계산
- 지나친 문맥 교환의 문제
  - 문맥저장과 복구에 CPU시간을 사용해서 효율성 떨어짐
  - 캐시메모리 데이타를 반복적으로 무효화
  - 캐시미스율이 증가
- 4GB 이상의 프로그램을 물리메모리에서 실행하는 방법
  - 운영체제는 프로세스가 필요한 메모리 공간을 가상주소로 할당
  - 물리메모리에는 필요한 부분만 적재
  - 불필요한 부분은 디스크의 스왑영역에 적재
  - 가상메모리 기술
- 페이지폴트를 처리하는 과정
  - CPU : 기존 작업을 백업
  - 페이지폴트 처리루틴 진행
    - 원하는 페이지를 메모리의 프레임으로 가져와서 유효비트를 1로 변경
  - 이제 CPU가 해당 페이지에 접근가능
- 파일디스크립터
  - 운영체제에서 파일을 식별하기 위한 저수준 정보
  - IPC(파이프, 소켓)도 파일
  - 표준입력0 표준출력1 표준에러2 도 파일
- EXT4 에서 디렉토리에서 내 파일의 데이타를 찾는 과정
  - 파일이 속한 디렉터리에서 파일이름에 해당하는 디렉토리 엔트리를 찾음.
  - 해당파일의 inode를 얻음.
  - inode번호로 inode테이블에서 inode찾음.
  - inode에는 파일속성, 데이타저장위치 포함.
- inode
  - 파일이 저장된 위치, 속성
  - 파일이름은 제외
- 공장초기화된 보조기억장치가 있음, 파일시스템을 만들고, 텍스트파일 저장.
  - 파티션 생성
  - 포매팅 : 파일시스템 생성
  - 파일시스템 마운트
  - 파일생성, 저장
- 메모리누수
  - 할당받은 메모리를 해제하지 않아 지속적으로 점유
  - 명시적인 해재
  - 가비지 컬렉션
- 스레드 join
  - 생성된 스레드가 완료될때까지 대기하는 메서드
- 멀티프로세스, 멀티스레드
  - 차이점 : 자원공유여부
  - 멀티스레드는 메모리, 파일을 공유함.
- hello라는 문자열 입력후 저장, 이 과정을 커널모드로 설명
  - 응용프로그램 : 운영체제 open() 호출
  - CPU : 유저모드 -> 커널모드
  - 커널 : 파일생성
  - CPU : 커널모드 -> 유저모드
  - 응용프로그램 : 운영체제 write() 호출
  - CPU : 유저모드 -> 커널모드
  - 커널 : 파일기록
  - CPU : 커널모드 -> 유저모드
  - 응용프로그램 : 운영체제 close() 호출
  - CPU : 유저모드 -> 커널모드
  - 커널 : 파일닫기
  - CPU : 커널모드 -> 유저모드
- 교착상태
  - 2개이상의 프로세스가 상대방의 자원을 기다리며 무한정 대기
  - 4조건
    - 상호배제
      - 한번에 하나씩 사용
    - 상호대기
      - 자원점유 프로세스가 다른자원 대기
    - 비선점
      - 자원을 점유하지 못하는 경우
    - 원형대기
- 블로킹 입출력, 논블로킹 입출력
- 디버깅시 주소는 물리메모리주소 or 가상메모리주소
  - 가상메모리 주소
  - 이 가상메모리 주소는 MMU에 의해 물리주소로 변환
- 메모리가 부족하다면
  - 디스크에 메모리페이지를 저장
  - 필요할때 다시 불러오기 
  - 스와핑
  - 슬래싱
    - 스와핑이 계속 발생해서 실제 작업이 일어나지 않는 상황.

# p256 자료구조

# p257 시간복잡도 공간복잡도
- 시간복잡도
  - 입력에 따른 시간의 점근적 상향
- 공간복잡도
  - 입력에 따른 메모리의 점근적 상향

# p300 트리의 종류
- 이진트리
  - 편향된 이진트리
- RB트리
  - 균형을 맞추는 트리
  - 이진트리의 문제
    - 삽입 삭제 연산을 반복하면 트리가 한쪽으로만 자라나는 편향.
    - 탐색속도가 O(n)으로 연결리스트와 다를바 없음.
  - 색상규칙
    - 루트노드 : 블랙
    - 리프노드 : 블랙
    - 레드노드의 자식은 블랙
  - 트리의 회전
    - 왼쪽회전
    - 오른쪽회전
- B트리
  - 대용량입출력
  - 균형을 유지하는 트리
  - 다진탐색트리
  - 한블록은 여러데이타를 포괄
  - 이진탐색트리에 비해 입출력 연산을 줄일수 있음.
- B+트리
  - 실질적인 데이타가 모두 최하위 리프노드에 있음.

# p322 깊이우선탐색 vs 넓이우선탐색

# p327 최단경로 알고리즘
- 시작점에서 목적지까지 가중치합이 최소가 되는 경로
- 지도서비스에서 목적지까지 이르는 최단거리

# p336 기술면접질문
- 시간복잡도와 빅오표기법 차이
  - 시간복잡도
    - 입력크기에 따른 프로그램 실행시간관계
    - 실행시간은 연산횟수에 비례
    - 연산횟수
  - 빅오표기법
    - 함수의 점근적 상향
- 해시테이블의 장단점
  - 장점
    - 빠르다
    - O(1)
  - 단점
    - 메모리를 많이 사용
- 연결리스트 장단점
  - 장점
    - 삽입 삭제 빠름.
  - 단점
    - 순차탐색 느림.

# p501 기술면접질문
- 브로드캐스트
  - 네트워크내 모든 호스트에게 패킷전송
  - ARP 요청
- 캡슐화
  - 상위계층에서 하위계층으로 내려갈때 헤더가 덧붙는 과정
- MAC주소, IP주소
  - MAC주소
    - 네트워크 인터페이스의 물리적 주소
    - 로컬 네트워크내에서 장치를 식별
  - IP주소
    - 호스트를 식별하는 논리적주소
- 서브네팅 필요
  - IP주소를 토대로 네트워크를 더 작은 서브네트워크로 나누기 위함.
  - IP주소와 네트워크를 효율적으로 관리
- NAT
  - IP주소를 변환하는 기술
  - 사설IP+포트와 공인IP+포트를 변환하는데 사용
- TCP 연결수립과정
  - 3way handshake
    - 클라->서버 : SYN
    - 서버->클라 : SYN-ACK
    - 클라->서버 : ACK
- 도메인네임을 웹사이트에 연동하는 과정
  - DNS서비스 제공업체에 DNS 자원 레코드를 추가
- HTTP 1.1, HTTP 2.0 차이점
  - 1.1
    - 평문 메시지
  - 2.0
    - 바이너리 메시지
    - 헤더압축
    - 서버푸시
    - 멀티플랙싱
    - HOL블로킹 문제를 완화

# p514 서버로서 DBMS
- SQL
  - DDL(Data Definition Language)
    - CREATE
      - 데이타베이스, 테이블, 뷰, 인덱스 생성
    - ALTER
    - DROP
      - 데이타베이스 삭제
    - TRUNCATE
      - 테이블구조유지, 모든레코드 삭제
  - DML(Manipulation)
    - SELECT
    - INSERT
    - UPDATE
    - DELETE
  - DCL(Control)
    - COMMIT
    - ROLLBACK
    - SAVEPOINT
  - TCL(Transaction Control Language)
    - GRANT
      - 권한 부여
    - REVOKE
      - 권한 회수

# p516 파일대신 데이타베이스 필요성
- 데이타 일관성 무결성
  - 레이스컨디션 문제
- 중복저장
- 변경시 연관변경 문제
- 정교한 검색
- 백업, 복구

# p523 트랜젝션과 ACID
- ACID
- Atomicity(원자성)
  - all or nothing
  - 모두 성공하거나 모두 실패
  - 일부 성공이나 일부 실패는 불허
- Consistency(일관성)
  - 트랜젝션 전후로 데이타베이스가 일관된 상태를 유지
  - 일관된 상태는 데이타베이스가 지켜야 하는 일련의 규칙을 모두 지키고 있는 상태
- Isolation(격리성)
  - 여러트랜젝션이 간섭받지 않는 상태
  - 레이스컨디션 방지
- Durability(지속성)
  - 트랜젝션이 성공후 그 결과가 영구히 반영

# p539 무결성 제약 조건
- 도메인 제약조건
- 키 제약조건
- 엔티티 무결성 제약조건
- 참조 무결성 제약조건

# p544 DDL
- 데이타베이스 생성

```
CREATE TABLE mydb;
SHOW DATABASES;
USE mydb;
```

- 테이블 생성

```
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    birth_date DATE,
    registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)

...
FOREIGN KEY (user_id) REFERENCES users(id)
...

DESCRIBE users;
```

- 테이블 변경

```
ALTER TABLE users   ADD     COLUMN HOBBY VARCHAR(50) NOT NULL;
...                 CHANGE
...                 DROP
...                 MODIFY
```

- 테이블, 데이타베이스 삭제

```
DROP DATABASE mydatabase;
DROP TABLE users;
```

- 테이블의 모든 레코드 삭제

```
TRUNCATE TABLE users;
```

- INSERT

```
INSERT INTO users(name) 
VALUES ("hhd")
```

- UPDATE

```
UPDATE users
SET name = "hhd"
WHERE id = "hhd"
```

- DELETE

```
DELETE FROM users
WHERE id = "hhd"
```

- 외래키 제약조건
  - CASCADE
    - 참조하는 데이타도 함께 수정/삭제
  - SET NULL
    - 참조하는 데이타를 NULL로 변경
  - SET DEFAULT
  - RESTRICTED
  - NO ACTION

```
CREATE TABLE posts (
    id PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    ...
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    ON UPDATE CASCADE,
    ON DELETE SET NULL
)
```

- SELECT

```
SELECT 필드1, 필드2
    FROM 테이블
    WHERE 조건식
    GROUP BY 그룹화할_필드
    HAVING 필터_조건
    ORDER BY 정렬할_필드
    LIMIT 레코드_제한
```

```
SELECT COUNT(*), AVG(gpa), MAX(gpa), MIN(gpa)
FROM STUDENTS;
```

# p563 GROUP BY

```
SELECT major, COUNT(*), AS student_count
FROM students
GROUP BY major;
```

# p564 HAVING

```
SELECT major, AVG(gpa)
FROM students
GROUP BY major;
```

```
SELECT major, AVG(gpa)
FROM students
GROUP BY major
HAVING AVG(gpa) >= 3.6
```

# p566 ORDER BY

```
SELECT first_name, last_name, gpa
FROM students
ORDER BY gpa DESC;
```

# p568 TCL(Transaction Control Language)

```
START TRANSACTION;

UPDATE ACCOUNTS
SET blance = balance - 100
WHERE account_id = 1;

COMMIT;
```

```
START TRANSACTION;

UPDATE ACCOUNTS
SET blance = balance - 100
WHERE account_id = 1;

ROLLBACK;
```

```
START TRANSACTION;

SAVEPOINT sp1;

UPDATE ACCOUNTS
SET blance = balance - 100
WHERE account_id = 1;

ROLLBACK TO SAVEPOINT sp1;
```

# p573 서브쿼리와 조인

- inner join

```
SELECT c.name, c.age, c.email, o.id, o.product_id, o.quantity, o.amount
FROM customers AS c 
INNER JOIN orders AS o 
ON c.id = o.customer_id;
```

- left outer join

```
SELECT c.name, c.age, c.email, o.id, o.product_id, o.quantity, o.amount
FROM customers AS c 
LEFT OUTER JOIN orders AS o 
ON c.id = o.customer_id;
```

# p584 뷰

```
CREATE VIEW myview AS
SELECT u.name, u.email, p.title
FROM users AS u, posts AS p
WHERE u.id = p.user_id
```

# p587 인덱스

```
CREATE INDEX 인덱스_이름 ON 테이블_이름(필드);

SHOW INDEX FROM 테이블_이름;

DROP INDEX 인덱스_이름 FROM 테이블_이름;
```

```
CREATE INDEX idx_nickname 
ON users(nickname);
```

# p597 1정규형
- 모든속성은 원자값을 갖음.
- 필드데이타가 더이상 쪼개질수 없음.
- before
  - 수강과목
    - 운영체제, 데이타베이스
    - 컴퓨터구조, 운영체제
- 문제점
  - 수강과목의 세부 데이타가 원자값이 아닌 배열.
- after
  - 수강과목
    - 운영체제
    - 데이타베이스
    - 컴퓨터구조
    - 운영체제

# p600 2정규형
- 1정규형을 만족함
- 기본키가 아닌 모든필드가 기본키에 종속
- before
  - 구매
    - id
    - 이름
    - 구매항목
    - 가격
    - 결제수단
- 문제점
  - 구매id
- after
  - 회원
    - id
    - 이름
  - 상품
    - id
    - 상품명
  - 구매
    - id
    - 회원id
    - 상품id
    - 결제수단

# p602 3정규형
- 1 2 정규형 만족
- 기본키가 아닌 모든키에 이행적 종속성이 없는 상태
- before
  - 학생
    - id
    - 학과
    - 학과사무실위치
- after
  - 학과
    - id
    - 이름
    - 사무실위치
  - 학생
    - id
    - 학과id

# p603 보이스/코드 정규형
- 1, 2, 3 만족
- 모든결정자가 후보키
- 즉 결정자는 유일해야 함.
- before
  - 수강
    - 학생id
    - 과목id
    - 교수id
- 문제점
  - 과목코드로 담당교수 특정 가능
  - 담당교수로 과목코드 특정 가능
  - 결정자가 2개로 보이스 코드 정규형 위반
- after
  - 수강
    - 학생id
    - 과목id
  - 과목
    - id
    - 교수id
- 정규형 정리
  - 1정규형
    - 모든속성이 원자값
    - 컬럼에 배열값이 들어가면 안됨
  - 2정규형
    - 부분함수 종속성 제거
    - id값으로 특정할 수 없는 컬럼이 있으면 안됨
  - 3정규형
    - 이행함수 종속성 제거
    - 레코드의 모든 컬럼이 id와 관련 있어야 함.
  - 보이스코드 정규형
    - 후보키 아닌 결정자 제거
    - FK만 있어야 하는데, FK의 주변컬럼이 함께 포함되면 안됨.
    - professor_id 만 있어야 하는데, professor_주민번호 는 유일하더라도 함께 있으면 안됨.

# p609 MongoDB
- 데이타베이스 생성, 컬렉션 생성
```
use mydb

db.createCollection("mycollection")

show dbs

show collections
```
- 단일 레코드 삽입
```
db.mycollection.insertOne({name:"kim", age:30})

db.mycollection.find()

db.mycollection.find({name:"kim"})

db.mycollection.find({age:{$gt:20}})

db.mycollection.find({
    $and
    [
        {name:"kim"},
        {age:12}
    ]
})
```
- 여러 레코드 삽입
```
db.mycollection.insertMany(
    {name:"kim", age:30},
    {name:"kim", age:30},
    {name:"kim", age:30},
    {name:"kim", age:30},
)
```
- 단일 도큐먼트 갱신
```
db.mycollection.updateOne(
    {name:"kim"},
    {$set: {age:30} }
)
```
- 여러 도큐먼트 갱신
```
db.mycollection.updateMany(
    {age:{$gt:20}},
    {$set:{status:"active"}}
)
```
- 삭제
```
db.mycollection.deleteOne( {name:"kim"} )
```

# p616 Redis
- 문자열타입 명령어
  - SET
  - SETNX
    - 키가 존재하지 않을때만 문자열 저장
  - GET
  - MGET
    - 여러 문자열 조회
  - DEL
```
SET k1 "hello"
```
```
SETNX k1 "hello2"
SETNX k2 "hello3"
```
```
GET k1
GET k2
```
```
DEL k2
```

# p626 기술면접 질문
- DB의 필요성
  - 일관성, 무결성
  - 레이스 컨디션
  - 중복저장
- ACID
  - A : 원자성
    - all or nothing
  - C : 일관성
    - 트랜젝션 전후에 상태 일관
  - I : 독립성
    - 트랜젝션간 독립적
  - D : 지속성
    - 트랜젝션 이후 결과가 영원히 저장
- 정규화가 필요하지 않은 상황
  - 테이블이 너무 많으면 빈번한 조인연산으로 성능저하
  - 하나의 테이블로 역정규화 필요
- 인덱스로 인한 성능저하
  - 인덱스는 SELECT 고성능, INSERT UPDATE DELETE 저성능
  - 조회가 빈번한 테이블만 인덱스 필요
- 인덱스에 B+트리가 사용되는 이유
  - 대용량 데이타에 대한 빠른 탐색
  - 균형잡힌 트리라서 검색이 빠름
  - 노드가 여러 자식을 갖아서 탐색 횟수가 적음
- 참조 무결성 제약조건
  - 외래키를 통해 테이블간 참조 관계에서 데이타의 일관성을 유지하기 위한 조건
  - 외래키는 테이블의 기본키 or NULL
- INNER JOIN, OUTER JOIN
  - INNER JOIN
    - 공통된 데이타가 있는 경우만 데이타 추출
  - OUTER JOIN
    - 공통된 데이타가 없는 행도 빈값으로 반환
- 모든직원의 이름 조회
```
SELECT name
FROM employees;
```
- 전직원 급여 10% 인상
```
UPDATE employees
SET salary = salary * 1.1;
```
- 부서ID를 추가
```
ALTER TABLE employees
ADD FOREIGN KEY (dept_id)
REFERENCES departments(id)
ON DELETE CASCADE
ON UPDATE SET NULL;
```
- 재무부서의 모든직원이름, 부서이름
```
SELECT e.name, d.name
FROM employees AS e
INNER JOIN departments AS d 
ON e.dept_id = d.id
WHERE d.name = "finance";
```
- SQL에서 뷰의 필요성
  - 복잡한 쿼리 단순화
  - 보안
- RDBMS, NoSQL 차이
  - 스키마고정, 스키마유연
  - 수평확장용이
- NoSQL 장점
  - 높은확장성
  - 빠른 읽기/쓰기
  - 엄격한 트랜젝션, 일관성 나쁨
- Redis 장점
  - 인메모리 데이타베이스라서 디스크접근시간 단축
  - 빠른 입출력
- DB샤딩
  - 샤드라는 여러 데이타베이스 서버에 테이블을 분할
  - 부하분산효과